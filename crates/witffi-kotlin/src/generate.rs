//! Kotlin bindings code generator.
//!
//! Walks the resolved WIT types and produces a single `Bindings.kt` file
//! containing:
//! 1. `@Keep` model classes for WIT records
//! 2. `@Keep` sealed class hierarchies for WIT variants
//! 3. Enum classes for WIT enums
//! 4. Inline value classes for WIT flags
//! 5. Type aliases for WIT type aliases
//! 6. A backend interface with one method per exported function
//! 7. An implementation class with JNI `external fun` declarations
//!    and `System.loadLibrary()` initialization
//!
//! The generated Kotlin code assumes a corresponding Rust JNI bridge is
//! linked at runtime. The bridge is produced by `witffi-rust`'s
//! `witffi_register_jni!` macro.

use std::collections::HashSet;
use std::fmt::Write;

use heck::ToLowerCamelCase;
use snafu::prelude::*;
use wit_parser::{Resolve, Type, TypeDefKind, TypeId, WorldId};

use witffi_core::{ExportedFunction, exported_functions, names};

/// Errors that can occur during Kotlin code generation.
#[derive(Debug, Snafu)]
pub enum Error {
    /// A write to the output buffer failed.
    #[snafu(display("code generation write error"))]
    Write { source: std::fmt::Error },
}

/// Configuration for the Kotlin generator.
#[derive(Debug, Clone)]
pub struct KotlinConfig {
    /// Kotlin package name (e.g. "zcash.eip681").
    ///
    /// If `None`, derived from the WIT package name (e.g.
    /// `zcash:eip681` becomes `zcash.eip681`).
    pub kotlin_package: Option<String>,

    /// Library name for `System.loadLibrary()` (e.g. "eip681ffi").
    pub lib_name: String,
}

impl Default for KotlinConfig {
    fn default() -> Self {
        Self {
            kotlin_package: None,
            lib_name: "witffi".to_string(),
        }
    }
}

/// Generates Kotlin bindings from a resolved WIT world.
pub struct KotlinGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: KotlinConfig,
}

impl<'a> KotlinGenerator<'a> {
    /// Create a new Kotlin generator.
    ///
    /// # Arguments
    ///
    /// * `resolve` — The resolved WIT package
    /// * `world_id` — The world to generate bindings for
    /// * `config` — Generator configuration (package, library name)
    pub fn new(resolve: &'a Resolve, world_id: WorldId, config: KotlinConfig) -> Self {
        Self {
            resolve,
            world_id,
            config,
        }
    }

    /// Generate all Kotlin bindings code as a single string.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    fn generate_inner(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// Auto-generated by witffi. Do not edit.")?;
        writeln!(out)?;

        let package = self.kotlin_package();
        writeln!(out, "package {package}")?;
        writeln!(out)?;

        writeln!(out, "import androidx.annotation.Keep")?;
        writeln!(out)?;

        self.generate_types(out)?;
        self.generate_backend_interface(out)?;
        self.generate_implementation_class(out)?;

        Ok(())
    }

    // ---- Package name derivation ----

    fn kotlin_package(&self) -> String {
        if let Some(ref pkg) = self.config.kotlin_package {
            return pkg.clone();
        }
        let world = &self.resolve.worlds[self.world_id];
        if let Some(pkg_id) = world.package {
            let pkg = &self.resolve.packages[pkg_id];
            return format!("{}.{}", pkg.name.namespace, pkg.name.name);
        }
        world.name.clone()
    }

    // ---- Reachable type collection ----

    fn collect_reachable_types(&self) -> Vec<TypeId> {
        let mut visited = HashSet::new();
        let mut order = Vec::new();

        let world = &self.resolve.worlds[self.world_id];
        for (_key, item) in &world.exports {
            if let wit_parser::WorldItem::Interface { id, .. } = item {
                let iface = &self.resolve.interfaces[*id];
                for (_name, type_id) in &iface.types {
                    self.visit_type_id(*type_id, &mut visited, &mut order);
                }
                for (_fname, func) in &iface.functions {
                    for p in &func.params {
                        self.visit_type(&p.ty, &mut visited, &mut order);
                    }
                    if let Some(ty) = &func.result {
                        self.visit_type(ty, &mut visited, &mut order);
                    }
                }
            }
        }

        order
    }

    fn visit_type_id(
        &self,
        type_id: TypeId,
        visited: &mut HashSet<TypeId>,
        order: &mut Vec<TypeId>,
    ) {
        if !visited.insert(type_id) {
            return;
        }

        let typedef = &self.resolve.types[type_id];
        match &typedef.kind {
            TypeDefKind::Record(record) => {
                for field in &record.fields {
                    self.visit_type(&field.ty, visited, order);
                }
            }
            TypeDefKind::Variant(variant) => {
                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        self.visit_type(ty, visited, order);
                    }
                }
            }
            TypeDefKind::List(ty) | TypeDefKind::Option(ty) => {
                self.visit_type(ty, visited, order);
            }
            TypeDefKind::Result(r) => {
                if let Some(ok) = &r.ok {
                    self.visit_type(ok, visited, order);
                }
                if let Some(err) = &r.err {
                    self.visit_type(err, visited, order);
                }
            }
            TypeDefKind::Tuple(tuple) => {
                for ty in &tuple.types {
                    self.visit_type(ty, visited, order);
                }
            }
            TypeDefKind::Type(ty) => {
                self.visit_type(ty, visited, order);
            }
            _ => {}
        }

        order.push(type_id);
    }

    fn visit_type(&self, ty: &Type, visited: &mut HashSet<TypeId>, order: &mut Vec<TypeId>) {
        if let Type::Id(id) = ty {
            self.visit_type_id(*id, visited, order);
        }
    }

    // ---- Type generation ----

    fn generate_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- Types ----")?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let kotlin_name = names::to_kotlin_type(wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/** {docs} */")?;
                }
                writeln!(out, "@Keep")?;
                writeln!(out, "class {kotlin_name}(")?;
                for field in &record.fields {
                    let field_name = names::to_kotlin_ident(&field.name);
                    let field_type = self.type_to_kotlin(&field.ty);
                    if let Some(docs) = &field.docs.contents {
                        writeln!(out, "    /** {docs} */")?;
                    }
                    writeln!(out, "    val {field_name}: {field_type},")?;
                }
                writeln!(out, ")")?;
                writeln!(out)?;
            }

            TypeDefKind::Variant(variant) => {
                let kotlin_name = names::to_kotlin_type(wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/** {docs} */")?;
                }
                writeln!(out, "@Keep")?;
                writeln!(out, "sealed class {kotlin_name} {{")?;
                for case in &variant.cases {
                    let case_name = names::to_kotlin_type(&case.name);
                    if let Some(docs) = &case.docs.contents {
                        writeln!(out, "    /** {docs} */")?;
                    }
                    if let Some(ty) = &case.ty {
                        let case_type = self.type_to_kotlin(ty);
                        writeln!(
                            out,
                            "    @Keep class {case_name}(val value: {case_type}) : {kotlin_name}()"
                        )?;
                    } else {
                        writeln!(out, "    @Keep class {case_name} : {kotlin_name}()")?;
                    }
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Enum(e) => {
                let kotlin_name = names::to_kotlin_type(wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/** {docs} */")?;
                }
                writeln!(out, "enum class {kotlin_name}(val value: Long) {{")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let case_name = names::to_kotlin_type(&case.name);
                    let comma = if i < e.cases.len() - 1 { "," } else { ";" };
                    writeln!(out, "    {case_name}({i}L){comma}")?;
                }
                writeln!(out, "    companion object {{")?;
                writeln!(
                    out,
                    "        fun fromValue(v: Long) = entries.first {{ it.value == v }}"
                )?;
                writeln!(out, "    }}")?;
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Flags(flags) => {
                let kotlin_name = names::to_kotlin_type(wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/** {docs} */")?;
                }
                writeln!(out, "@JvmInline")?;
                writeln!(out, "value class {kotlin_name}(val rawValue: Long) {{")?;
                writeln!(out, "    companion object {{")?;
                for (i, flag) in flags.flags.iter().enumerate() {
                    let flag_name = flag.name.to_uppercase().replace('-', "_");
                    writeln!(out, "        val {flag_name} = {kotlin_name}(1L shl {i})")?;
                }
                writeln!(out, "    }}")?;
                writeln!(
                    out,
                    "    operator fun plus(other: {kotlin_name}) = {kotlin_name}(rawValue or other.rawValue)"
                )?;
                writeln!(
                    out,
                    "    fun contains(flag: {kotlin_name}) = rawValue and flag.rawValue == flag.rawValue"
                )?;
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Type(inner) => {
                let kotlin_name = names::to_kotlin_type(wit_name);
                let inner_ty = self.type_to_kotlin(inner);
                // Skip self-referential aliases
                if kotlin_name != inner_ty {
                    writeln!(out, "typealias {kotlin_name} = {inner_ty}")?;
                    writeln!(out)?;
                }
            }

            TypeDefKind::List(_)
            | TypeDefKind::Option(_)
            | TypeDefKind::Result(_)
            | TypeDefKind::Tuple(_) => {
                // Named type aliases (e.g. `type u256 = list<u8>` in WIT)
                // get resolved by the parser so their kind is the target
                // directly. If the type has a name, emit a typealias.
                if typedef.name.is_some() {
                    let kotlin_name = names::to_kotlin_type(wit_name);
                    let target = self.type_to_kotlin_for_typedef(type_id);
                    if kotlin_name != target {
                        writeln!(out, "typealias {kotlin_name} = {target}")?;
                        writeln!(out)?;
                    }
                }
            }

            _ => {}
        }

        Ok(())
    }

    /// Map a WIT type to its Kotlin representation.
    fn type_to_kotlin(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "Boolean".to_string(),
            Type::U8 | Type::S8 => "Byte".to_string(),
            Type::U16 | Type::S16 => "Short".to_string(),
            Type::U32 | Type::S32 => "Int".to_string(),
            Type::U64 | Type::S64 => "Long".to_string(),
            Type::F32 => "Float".to_string(),
            Type::F64 => "Double".to_string(),
            Type::Char => "Char".to_string(),
            Type::String => "String".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "ByteArray".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("Array<{}>", self.type_to_kotlin(inner))
                    }
                    TypeDefKind::Option(inner) => {
                        format!("{}?", self.type_to_kotlin(inner))
                    }
                    TypeDefKind::Result(r) => {
                        // In Kotlin, result<T, E> becomes just T (throws on error)
                        r.ok.as_ref()
                            .map(|t| self.type_to_kotlin(t))
                            .unwrap_or_else(|| "Unit".to_string())
                    }
                    TypeDefKind::Tuple(tuple) => match tuple.types.len() {
                        2 => {
                            let a = self.type_to_kotlin(&tuple.types[0]);
                            let b = self.type_to_kotlin(&tuple.types[1]);
                            format!("Pair<{a}, {b}>")
                        }
                        3 => {
                            let a = self.type_to_kotlin(&tuple.types[0]);
                            let b = self.type_to_kotlin(&tuple.types[1]);
                            let c = self.type_to_kotlin(&tuple.types[2]);
                            format!("Triple<{a}, {b}, {c}>")
                        }
                        _ => {
                            // Fallback: use a generic list or object
                            "Any".to_string()
                        }
                    },
                    TypeDefKind::Type(aliased) => self.type_to_kotlin(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Any");
                        names::to_kotlin_type(name)
                    }
                }
            }
            Type::ErrorContext => "String".to_string(),
        }
    }

    /// Map a named TypeId directly to its Kotlin representation.
    ///
    /// This is used for type aliases where the typedef's kind is the target
    /// type directly (e.g. `type u256 = list<u8>` has kind `List(U8)`).
    fn type_to_kotlin_for_typedef(&self, type_id: TypeId) -> String {
        let typedef = &self.resolve.types[type_id];
        match &typedef.kind {
            TypeDefKind::List(Type::U8) => "ByteArray".to_string(),
            TypeDefKind::List(inner) => {
                format!("Array<{}>", self.type_to_kotlin(inner))
            }
            TypeDefKind::Option(inner) => {
                format!("{}?", self.type_to_kotlin(inner))
            }
            TypeDefKind::Result(r) => {
                r.ok.as_ref()
                    .map(|t| self.type_to_kotlin(t))
                    .unwrap_or_else(|| "Unit".to_string())
            }
            TypeDefKind::Tuple(tuple) => match tuple.types.len() {
                2 => {
                    let a = self.type_to_kotlin(&tuple.types[0]);
                    let b = self.type_to_kotlin(&tuple.types[1]);
                    format!("Pair<{a}, {b}>")
                }
                3 => {
                    let a = self.type_to_kotlin(&tuple.types[0]);
                    let b = self.type_to_kotlin(&tuple.types[1]);
                    let c = self.type_to_kotlin(&tuple.types[2]);
                    format!("Triple<{a}, {b}, {c}>")
                }
                _ => "Any".to_string(),
            },
            _ => {
                let name = typedef.name.as_deref().unwrap_or("Any");
                names::to_kotlin_type(name)
            }
        }
    }

    // ---- Result decomposition ----

    fn decompose_result(&self, result: &Option<Type>) -> Option<(Option<Type>, Option<Type>)> {
        match result {
            Some(Type::Id(id)) => {
                let typedef = &self.resolve.types[*id];
                if let TypeDefKind::Result(r) = &typedef.kind {
                    Some((r.ok, r.err))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    // ---- Backend interface generation ----

    fn generate_backend_interface(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let world_name = names::to_kotlin_type(&world.name);
        let interface_name = format!("{world_name}Backend");

        writeln!(out, "// ---- Backend interface ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/** Interface defining the {world_name} API contract. */"
        )?;
        writeln!(out, "interface {interface_name} {{")?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            let method_name = self.method_name(ef);
            let result_decomposed = self.decompose_result(&ef.function.result);

            let params: Vec<String> = ef
                .function
                .params
                .iter()
                .map(|p| {
                    format!(
                        "{}: {}",
                        names::to_kotlin_ident(&p.name),
                        self.type_to_kotlin(&p.ty)
                    )
                })
                .collect();

            let ret_type = if let Some((ref ok_ty, _)) = result_decomposed {
                // result<T, E> -> returns T, throws on E
                ok_ty
                    .as_ref()
                    .map(|t| self.type_to_kotlin(t))
                    .unwrap_or_else(|| "Unit".to_string())
            } else {
                match &ef.function.result {
                    Some(ty) => self.type_to_kotlin(ty),
                    None => "Unit".to_string(),
                }
            };

            if ret_type == "Unit" {
                writeln!(out, "    fun {method_name}({})", params.join(", "))?;
            } else {
                writeln!(
                    out,
                    "    fun {method_name}({}): {ret_type}",
                    params.join(", ")
                )?;
            }
        }

        writeln!(out, "}}")?;
        writeln!(out)?;

        Ok(())
    }

    // ---- Implementation class generation ----

    fn generate_implementation_class(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let world_name = names::to_kotlin_type(&world.name);
        let interface_name = format!("{world_name}Backend");
        let lib_name = &self.config.lib_name;

        writeln!(out, "// ---- Implementation ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/** JNI-backed implementation of [{interface_name}]. */"
        )?;
        writeln!(
            out,
            "class {world_name}(libraryName: String = \"{lib_name}\") : {interface_name} {{"
        )?;
        writeln!(out, "    companion object {{")?;
        writeln!(out, "        private var loaded = false")?;
        writeln!(out)?;
        writeln!(out, "        @Synchronized")?;
        writeln!(out, "        fun loadLibrary(name: String) {{")?;
        writeln!(out, "            if (!loaded) {{")?;
        writeln!(out, "                System.loadLibrary(name)")?;
        writeln!(out, "                loaded = true")?;
        writeln!(out, "            }}")?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        // Generate external fun declarations
        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            self.generate_external_fun(out, ef)?;
        }

        writeln!(out, "    }}")?;
        writeln!(out)?;

        // init block
        writeln!(out, "    init {{ loadLibrary(libraryName) }}")?;
        writeln!(out)?;

        // Override methods that delegate to companion external funs
        for ef in &funcs {
            self.generate_override_method(out, ef)?;
        }

        writeln!(out, "}}")?;

        Ok(())
    }

    fn generate_external_fun(&self, out: &mut String, ef: &ExportedFunction) -> std::fmt::Result {
        let native_method = self.native_method_name(ef);
        let result_decomposed = self.decompose_result(&ef.function.result);

        let params: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                format!(
                    "{}: {}",
                    names::to_kotlin_ident(&p.name),
                    self.type_to_kotlin(&p.ty)
                )
            })
            .collect();

        let ret_type = if let Some((ref ok_ty, _)) = result_decomposed {
            ok_ty
                .as_ref()
                .map(|t| self.type_to_kotlin(t))
                .unwrap_or_else(|| "Unit".to_string())
        } else {
            match &ef.function.result {
                Some(ty) => self.type_to_kotlin(ty),
                None => "Unit".to_string(),
            }
        };

        if ret_type == "Unit" {
            writeln!(
                out,
                "        @JvmStatic private external fun {native_method}({})",
                params.join(", ")
            )?;
        } else {
            writeln!(
                out,
                "        @JvmStatic private external fun {native_method}({}): {ret_type}",
                params.join(", ")
            )?;
        }

        Ok(())
    }

    fn generate_override_method(
        &self,
        out: &mut String,
        ef: &ExportedFunction,
    ) -> std::fmt::Result {
        let method_name = self.method_name(ef);
        let native_method = self.native_method_name(ef);
        let result_decomposed = self.decompose_result(&ef.function.result);

        let params: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                format!(
                    "{}: {}",
                    names::to_kotlin_ident(&p.name),
                    self.type_to_kotlin(&p.ty)
                )
            })
            .collect();

        let arg_names: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| names::to_kotlin_ident(&p.name))
            .collect();

        let ret_type = if let Some((ref ok_ty, _)) = result_decomposed {
            ok_ty
                .as_ref()
                .map(|t| self.type_to_kotlin(t))
                .unwrap_or_else(|| "Unit".to_string())
        } else {
            match &ef.function.result {
                Some(ty) => self.type_to_kotlin(ty),
                None => "Unit".to_string(),
            }
        };

        if ret_type == "Unit" {
            writeln!(
                out,
                "    override fun {method_name}({}) {{",
                params.join(", ")
            )?;
            writeln!(out, "        {native_method}({})", arg_names.join(", "))?;
            writeln!(out, "    }}")?;
        } else {
            writeln!(
                out,
                "    override fun {method_name}({}): {ret_type} {{",
                params.join(", ")
            )?;
            writeln!(
                out,
                "        return {native_method}({})",
                arg_names.join(", ")
            )?;
            writeln!(out, "    }}")?;
        }
        writeln!(out)?;

        Ok(())
    }

    // ---- Naming helpers ----

    fn method_name(&self, ef: &ExportedFunction) -> String {
        if ef.interface_name.is_empty() {
            ef.function_name.to_lower_camel_case()
        } else {
            format!("{}-{}", ef.interface_name, ef.function_name).to_lower_camel_case()
        }
    }

    fn native_method_name(&self, ef: &ExportedFunction) -> String {
        let pascal = names::to_kotlin_type(&if ef.interface_name.is_empty() {
            ef.function_name.clone()
        } else {
            format!("{}-{}", ef.interface_name, ef.function_name)
        });
        format!("native{pascal}")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use witffi_core::load_wit;

    fn test_config() -> KotlinConfig {
        KotlinConfig {
            kotlin_package: Some("zcash.eip681".to_string()),
            lib_name: "eip681ffi".to_string(),
        }
    }

    #[test]
    fn test_generate_kotlin_from_eip681() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = KotlinGenerator::new(&resolve, world_id, test_config());
        let code = generator
            .generate()
            .expect("failed to generate Kotlin code");

        eprintln!("=== Generated Kotlin ===\n{code}");

        // Package
        assert!(
            code.contains("package zcash.eip681"),
            "missing package declaration"
        );

        // Import
        assert!(
            code.contains("import androidx.annotation.Keep"),
            "missing @Keep import"
        );

        // Record
        assert!(
            code.contains("class NativeRequest("),
            "missing NativeRequest class"
        );
        assert!(
            code.contains("val schemaPrefix: String,"),
            "missing schemaPrefix field"
        );
        assert!(
            code.contains("val chainId: Long?,"),
            "missing chainId nullable field"
        );
        assert!(
            code.contains("val valueAtomic: ByteArray?,"),
            "missing valueAtomic ByteArray? field"
        );

        // Erc20 record
        assert!(
            code.contains("class Erc20Request("),
            "missing Erc20Request class"
        );
        assert!(
            code.contains("val valueAtomic: ByteArray,"),
            "missing non-nullable valueAtomic for Erc20Request"
        );

        // Variant (sealed class)
        assert!(
            code.contains("sealed class TransactionRequest"),
            "missing TransactionRequest sealed class"
        );
        assert!(
            code.contains("class Native(val value: NativeRequest) : TransactionRequest()"),
            "missing Native variant subclass"
        );
        assert!(
            code.contains("class Erc20(val value: Erc20Request) : TransactionRequest()"),
            "missing Erc20 variant subclass"
        );
        assert!(
            code.contains("class Unrecognised(val value: String) : TransactionRequest()"),
            "missing Unrecognised variant subclass"
        );
    }

    #[test]
    fn test_kotlin_backend_interface() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = KotlinGenerator::new(&resolve, world_id, test_config());
        let code = generator
            .generate()
            .expect("failed to generate Kotlin code");

        // Backend interface
        assert!(
            code.contains("interface Eip681Backend"),
            "missing Eip681Backend interface"
        );
        assert!(
            code.contains("fun parserParse(input: String): TransactionRequest"),
            "missing parserParse method in backend interface"
        );
    }

    #[test]
    fn test_kotlin_implementation_class() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = KotlinGenerator::new(&resolve, world_id, test_config());
        let code = generator
            .generate()
            .expect("failed to generate Kotlin code");

        // Implementation class
        assert!(
            code.contains("class Eip681(libraryName: String = \"eip681ffi\") : Eip681Backend"),
            "missing Eip681 implementation class"
        );

        // Library loading
        assert!(
            code.contains("System.loadLibrary(name)"),
            "missing System.loadLibrary call"
        );

        // External fun
        assert!(
            code.contains("external fun nativeParserParse(input: String): TransactionRequest"),
            "missing nativeParserParse external fun"
        );

        // Override method
        assert!(
            code.contains("override fun parserParse(input: String): TransactionRequest"),
            "missing override parserParse method"
        );
    }

    #[test]
    fn test_kotlin_type_mapping() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = KotlinGenerator::new(&resolve, world_id, test_config());

        // Test primitive type mapping
        assert_eq!(generator.type_to_kotlin(&Type::Bool), "Boolean");
        assert_eq!(generator.type_to_kotlin(&Type::U8), "Byte");
        assert_eq!(generator.type_to_kotlin(&Type::U16), "Short");
        assert_eq!(generator.type_to_kotlin(&Type::U32), "Int");
        assert_eq!(generator.type_to_kotlin(&Type::U64), "Long");
        assert_eq!(generator.type_to_kotlin(&Type::S8), "Byte");
        assert_eq!(generator.type_to_kotlin(&Type::S16), "Short");
        assert_eq!(generator.type_to_kotlin(&Type::S32), "Int");
        assert_eq!(generator.type_to_kotlin(&Type::S64), "Long");
        assert_eq!(generator.type_to_kotlin(&Type::F32), "Float");
        assert_eq!(generator.type_to_kotlin(&Type::F64), "Double");
        assert_eq!(generator.type_to_kotlin(&Type::Char), "Char");
        assert_eq!(generator.type_to_kotlin(&Type::String), "String");
    }

    #[test]
    fn test_kotlin_package_derivation() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        // With explicit package
        let generator = KotlinGenerator::new(
            &resolve,
            world_id,
            KotlinConfig {
                kotlin_package: Some("com.example.test".to_string()),
                lib_name: "test".to_string(),
            },
        );
        assert_eq!(generator.kotlin_package(), "com.example.test");

        // With derived package from WIT
        let generator = KotlinGenerator::new(
            &resolve,
            world_id,
            KotlinConfig {
                kotlin_package: None,
                lib_name: "test".to_string(),
            },
        );
        assert_eq!(generator.kotlin_package(), "zcash.eip681");
    }

    #[test]
    fn test_kotlin_typealias_for_u256() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = KotlinGenerator::new(&resolve, world_id, test_config());
        let code = generator
            .generate()
            .expect("failed to generate Kotlin code");

        // u256 = list<u8> should become a ByteArray typealias
        assert!(
            code.contains("typealias U256 = ByteArray"),
            "missing U256 typealias"
        );
    }
}
