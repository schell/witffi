//! Rust FFI scaffolding code generator.
//!
//! Walks the resolved WIT types and produces:
//! 1. Idiomatic Rust types for all records, variants, enums, flags
//! 2. A Rust trait with one method per exported function (using idiomatic types)
//! 3. A `witffi_register_ffi!` macro that generates `#[repr(C)]` shadow types,
//!    conversion logic, `extern "C"` wrapper functions, and error handling
//! 4. A `witffi_register_jni!` macro that generates JNI `Java_` entry points,
//!    JVM object construction, and exception-based error handling
//! 5. `free_*` functions for heap-allocated C-ABI return types (inside the FFI macro)
//! 6. A C header string

use std::collections::HashSet;
use std::fmt::Write;

use heck::ToSnakeCase;
use snafu::prelude::*;
use wit_parser::{Resolve, Type, TypeDefKind, TypeId, WorldId};

use witffi_core::{ExportedFunction, exported_functions, names};

/// Errors that can occur during Rust code generation.
#[derive(Debug, Snafu)]
pub enum Error {
    /// A write to the output buffer failed.
    #[snafu(display("code generation write error"))]
    Write { source: std::fmt::Error },
}

/// Configuration for the Rust generator.
#[derive(Debug, Clone)]
pub struct RustConfig {
    /// Prefix for C function names (e.g. "zcash_eip681").
    pub c_prefix: String,
    /// Prefix for C type names (e.g. "Ffi").
    pub c_type_prefix: String,
    /// Kotlin package for JNI class paths (e.g. "zcash.eip681").
    /// Required for `witffi_register_jni!` generation.
    pub kotlin_package: Option<String>,
    /// Library name for JNI `System.loadLibrary()` (e.g. "eip681ffi").
    pub library_name: Option<String>,
}

impl Default for RustConfig {
    fn default() -> Self {
        Self {
            c_prefix: "witffi".to_string(),
            c_type_prefix: "Ffi".to_string(),
            kotlin_package: None,
            library_name: None,
        }
    }
}

/// Generates Rust scaffolding code from a resolved WIT world.
pub struct RustGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: RustConfig,
}

impl<'a> RustGenerator<'a> {
    pub fn new(resolve: &'a Resolve, world_id: WorldId, config: RustConfig) -> Self {
        Self {
            resolve,
            world_id,
            config,
        }
    }

    /// Generate all Rust scaffolding code.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    /// Generate a C header string.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate_c_header(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_c_header_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    fn generate_inner(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// Auto-generated by witffi. Do not edit.")?;
        writeln!(out)?;

        self.generate_idiomatic_types(out)?;
        self.generate_trait(out)?;
        self.generate_register_ffi_macro(out)?;
        self.generate_register_jni_macro(out)?;

        Ok(())
    }

    fn generate_c_header_inner(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* Auto-generated by witffi. Do not edit. */")?;
        writeln!(out, "#pragma once")?;
        writeln!(out)?;
        writeln!(out, "#include <stdint.h>")?;
        writeln!(out, "#include <stdbool.h>")?;
        writeln!(out, "#include <stddef.h>")?;
        writeln!(out)?;
        writeln!(out, "#include \"witffi_types.h\"")?;
        writeln!(out)?;
        writeln!(out, "#ifdef __cplusplus")?;
        writeln!(out, "extern \"C\" {{")?;
        writeln!(out, "#endif")?;
        writeln!(out)?;

        self.generate_c_types(out)?;
        writeln!(out)?;
        self.generate_c_function_decls(out)?;
        writeln!(out)?;
        self.generate_c_free_decls(out)?;

        writeln!(out)?;
        writeln!(out, "#ifdef __cplusplus")?;
        writeln!(out, "}}")?;
        writeln!(out, "#endif")?;

        Ok(())
    }

    // ---- Helpers for collecting reachable types ----

    /// Collect all type IDs reachable from the world's exports,
    /// following type aliases and nested type references.
    fn collect_reachable_types(&self) -> Vec<TypeId> {
        let mut visited = HashSet::new();
        let mut order = Vec::new();

        let world = &self.resolve.worlds[self.world_id];
        for (_key, item) in &world.exports {
            if let wit_parser::WorldItem::Interface { id, .. } = item {
                let iface = &self.resolve.interfaces[*id];
                // Collect types directly defined/referenced in this interface
                for (_name, type_id) in &iface.types {
                    self.visit_type_id(*type_id, &mut visited, &mut order);
                }
                // Also collect types from function params and results
                for (_fname, func) in &iface.functions {
                    for p in &func.params {
                        self.visit_type(&p.ty, &mut visited, &mut order);
                    }
                    if let Some(ty) = &func.result {
                        self.visit_type(ty, &mut visited, &mut order);
                    }
                }
            }
        }

        order
    }

    fn visit_type_id(
        &self,
        type_id: TypeId,
        visited: &mut HashSet<TypeId>,
        order: &mut Vec<TypeId>,
    ) {
        if !visited.insert(type_id) {
            return;
        }

        let typedef = &self.resolve.types[type_id];

        // Visit child types first (depth-first) so dependencies come before dependents
        match &typedef.kind {
            TypeDefKind::Record(record) => {
                for field in &record.fields {
                    self.visit_type(&field.ty, visited, order);
                }
            }
            TypeDefKind::Variant(variant) => {
                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        self.visit_type(ty, visited, order);
                    }
                }
            }
            TypeDefKind::List(ty) | TypeDefKind::Option(ty) => {
                self.visit_type(ty, visited, order);
            }
            TypeDefKind::Result(r) => {
                if let Some(ok) = &r.ok {
                    self.visit_type(ok, visited, order);
                }
                if let Some(err) = &r.err {
                    self.visit_type(err, visited, order);
                }
            }
            TypeDefKind::Tuple(tuple) => {
                for ty in &tuple.types {
                    self.visit_type(ty, visited, order);
                }
            }
            TypeDefKind::Type(ty) => {
                self.visit_type(ty, visited, order);
            }
            _ => {}
        }

        order.push(type_id);
    }

    fn visit_type(&self, ty: &Type, visited: &mut HashSet<TypeId>, order: &mut Vec<TypeId>) {
        if let Type::Id(id) = ty {
            self.visit_type_id(*id, visited, order);
        }
    }

    // ---- Helpers for understanding function result types ----

    /// Check if a function's return type is `result<T, E>` at the top level.
    /// Returns `(Some(ok_type), Some(err_type))` if so.
    fn decompose_result(&self, result: &Option<Type>) -> Option<(Option<Type>, Option<Type>)> {
        match result {
            Some(Type::Id(id)) => {
                let typedef = &self.resolve.types[*id];
                if let TypeDefKind::Result(r) = &typedef.kind {
                    Some((r.ok, r.err))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    // ---- Idiomatic Rust type generation ----

    fn generate_idiomatic_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- Idiomatic Rust types ----")?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_idiomatic_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_idiomatic_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let rust_name = names::to_rust_type(wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "#[derive(Debug, Clone)]")?;
                writeln!(out, "pub struct {rust_name} {{")?;
                for field in &record.fields {
                    let field_name = names::to_rust_ident(&field.name);
                    let field_type = self.type_to_idiomatic(&field.ty);
                    if let Some(docs) = &field.docs.contents {
                        writeln!(out, "    /// {docs}")?;
                    }
                    writeln!(out, "    pub {field_name}: {field_type},")?;
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Variant(variant) => {
                let rust_name = names::to_rust_type(wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "#[derive(Debug, Clone)]")?;
                writeln!(out, "pub enum {rust_name} {{")?;
                for case in &variant.cases {
                    let variant_name = names::to_rust_type(&case.name);
                    if let Some(docs) = &case.docs.contents {
                        writeln!(out, "    /// {docs}")?;
                    }
                    if let Some(ty) = &case.ty {
                        let case_type = self.type_to_idiomatic(ty);
                        writeln!(out, "    {variant_name}({case_type}),")?;
                    } else {
                        writeln!(out, "    {variant_name},")?;
                    }
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Enum(e) => {
                let rust_name = names::to_rust_type(wit_name);
                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "#[derive(Debug, Clone, Copy, PartialEq, Eq)]")?;
                writeln!(out, "pub enum {rust_name} {{")?;
                for case in &e.cases {
                    let case_name = names::to_rust_type(&case.name);
                    writeln!(out, "    {case_name},")?;
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Flags(flags) => {
                let rust_name = names::to_rust_type(wit_name);
                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "pub type {rust_name} = u32;")?;
                for (i, flag) in flags.flags.iter().enumerate() {
                    let const_name = names::to_c_enum_variant(wit_name, &flag.name);
                    writeln!(out, "pub const {const_name}: {rust_name} = 1 << {i};")?;
                }
                writeln!(out)?;
            }

            TypeDefKind::Type(inner) => {
                let rust_name = names::to_rust_type(wit_name);
                let inner_ty = self.type_to_idiomatic(inner);
                // Skip self-referential aliases (from `use` across interfaces)
                if rust_name != inner_ty {
                    writeln!(out, "pub type {rust_name} = {inner_ty};")?;
                    writeln!(out)?;
                }
            }

            TypeDefKind::List(_)
            | TypeDefKind::Option(_)
            | TypeDefKind::Result(_)
            | TypeDefKind::Tuple(_) => {
                // Handled inline when they appear as field/param types
            }

            other => {
                writeln!(
                    out,
                    "// TODO: generate type for {wit_name} (kind: {})",
                    other.as_str()
                )?;
            }
        }

        Ok(())
    }

    /// Map a WIT type to its idiomatic Rust representation.
    fn type_to_idiomatic(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::S8 => "i8".to_string(),
            Type::S16 => "i16".to_string(),
            Type::S32 => "i32".to_string(),
            Type::S64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::Char => "char".to_string(),
            Type::String => "String".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "Vec<u8>".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("Vec<{}>", self.type_to_idiomatic(inner))
                    }
                    TypeDefKind::Option(inner) => {
                        format!("Option<{}>", self.type_to_idiomatic(inner))
                    }
                    TypeDefKind::Result(r) => {
                        let ok_ty =
                            r.ok.as_ref()
                                .map(|t| self.type_to_idiomatic(t))
                                .unwrap_or_else(|| "()".to_string());
                        let err_ty = r
                            .err
                            .as_ref()
                            .map(|t| self.type_to_idiomatic(t))
                            .unwrap_or_else(|| "()".to_string());
                        format!("Result<{ok_ty}, {err_ty}>")
                    }
                    TypeDefKind::Tuple(tuple) => {
                        let types: Vec<String> = tuple
                            .types
                            .iter()
                            .map(|t| self.type_to_idiomatic(t))
                            .collect();
                        format!("({})", types.join(", "))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_idiomatic(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        names::to_rust_type(name)
                    }
                }
            }
            Type::ErrorContext => "String".to_string(),
        }
    }

    // ---- Trait generation ----

    fn generate_trait(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let trait_name = names::to_rust_type(&world.name);

        writeln!(out, "// ---- Implementation trait ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/// Trait that library authors implement to provide the FFI functions."
        )?;
        writeln!(
            out,
            "/// Each method corresponds to a WIT exported function."
        )?;
        writeln!(out, "pub trait {trait_name} {{")?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            let method_name = self.trait_method_name(ef);

            let params: Vec<String> = ef
                .function
                .params
                .iter()
                .map(|p| {
                    format!(
                        "{}: {}",
                        names::to_rust_ident(&p.name),
                        self.type_to_trait_param(&p.ty)
                    )
                })
                .collect();

            let ret = self.function_return_to_trait(&ef.function.result);

            writeln!(out, "    fn {method_name}({}) -> {ret};", params.join(", "))?;
        }

        writeln!(out, "}}")?;
        Ok(())
    }

    fn trait_method_name(&self, ef: &ExportedFunction) -> String {
        if ef.interface_name.is_empty() {
            names::to_rust_ident(&ef.function_name)
        } else {
            names::to_rust_ident(&format!("{}-{}", ef.interface_name, ef.function_name))
        }
    }

    /// Map a WIT type to its Rust representation for trait method parameters.
    ///
    /// Parameters use borrowed types where possible: `&str` for strings,
    /// `&[u8]` for byte slices.
    fn type_to_trait_param(&self, ty: &Type) -> String {
        match ty {
            Type::String => "&str".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "&[u8]".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("Vec<{}>", self.type_to_idiomatic(inner))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_trait_param(aliased),
                    _ => self.type_to_idiomatic(ty),
                }
            }
            _ => self.type_to_idiomatic(ty),
        }
    }

    fn function_return_to_trait(&self, result: &Option<Type>) -> String {
        match result {
            Some(ty) => self.type_to_idiomatic(ty),
            None => "()".to_string(),
        }
    }

    // ---- C-ABI type mapping (used by witffi_register_ffi! and C header) ----

    /// Map a WIT type to its Rust FFI-safe `#[repr(C)]` representation.
    fn type_to_c_rust(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::S8 => "i8".to_string(),
            Type::S16 => "i16".to_string(),
            Type::S32 => "i32".to_string(),
            Type::S64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::Char => "u32".to_string(),
            Type::String => "witffi_types::FfiByteBuffer".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(inner) => match inner {
                        Type::U8 => "witffi_types::FfiByteBuffer".to_string(),
                        _ => format!(
                            "witffi_types::FfiByteBuffer /* list<{}> */",
                            self.type_to_c_rust(inner)
                        ),
                    },
                    TypeDefKind::Option(inner) => {
                        format!("*mut {}", self.type_to_c_rust(inner))
                    }
                    TypeDefKind::Result(result) => {
                        let ok_ty = result
                            .ok
                            .as_ref()
                            .map(|t| self.type_to_c_rust(t))
                            .unwrap_or_else(|| "()".to_string());
                        format!("/* result<{ok_ty}, ...> */")
                    }
                    TypeDefKind::Tuple(tuple) => {
                        let types: Vec<String> =
                            tuple.types.iter().map(|t| self.type_to_c_rust(t)).collect();
                        format!("/* tuple<{}> */", types.join(", "))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_c_rust(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        names::to_c_type(&self.config.c_type_prefix, name)
                    }
                }
            }
            Type::ErrorContext => "u32 /* error-context */".to_string(),
        }
    }

    /// Map a WIT type to its FFI-safe input representation.
    ///
    /// Input types differ from output types: strings and byte slices use
    /// `FfiByteSlice` (const pointer, caller-owned) rather than `FfiByteBuffer`
    /// (mutable pointer, callee-owned).
    fn type_to_ffi_input(&self, ty: &Type) -> String {
        match ty {
            Type::String => "witffi_types::FfiByteSlice".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "witffi_types::FfiByteSlice".to_string(),
                    TypeDefKind::List(_) => "witffi_types::FfiByteSlice".to_string(),
                    TypeDefKind::Type(aliased) => self.type_to_ffi_input(aliased),
                    _ => self.type_to_c_rust(ty),
                }
            }
            _ => self.type_to_c_rust(ty),
        }
    }

    // ---- witffi_register_ffi! macro generation ----

    fn generate_register_ffi_macro(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let trait_name = names::to_rust_type(&world.name);
        let prefix = self.config.c_prefix.to_snake_case();

        writeln!(out, "// ---- C-ABI Registration macro ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/// Register a concrete type for C-ABI FFI (Swift, Go, C consumers)."
        )?;
        writeln!(out, "///")?;
        writeln!(
            out,
            "/// This macro generates `#[repr(C)]` shadow types, conversion logic,"
        )?;
        writeln!(
            out,
            "/// `extern \"C\"` wrapper functions, error handling, and free functions."
        )?;
        writeln!(out, "///")?;
        writeln!(out, "/// # Example")?;
        writeln!(out, "///")?;
        writeln!(out, "/// ```ignore")?;
        writeln!(out, "/// struct MyImpl;")?;
        writeln!(out, "/// impl {trait_name} for MyImpl {{")?;
        writeln!(out, "///     // ... implement trait methods ...")?;
        writeln!(out, "/// }}")?;
        writeln!(out, "/// witffi_register_ffi!(MyImpl);")?;
        writeln!(out, "/// ```")?;
        writeln!(out, "#[macro_export]")?;
        writeln!(out, "macro_rules! witffi_register_ffi {{")?;
        writeln!(out, "    ($impl_type:ty) => {{")?;
        writeln!(out)?;

        // Generate repr(C) shadow types inside the macro
        self.generate_ffi_shadow_types(out)?;

        // Generate conversion functions (idiomatic -> repr(C))
        self.generate_ffi_conversions(out)?;

        // Generate free functions
        self.generate_ffi_free_functions(out)?;

        // Thread-local error storage
        writeln!(
            out,
            "        // Last error message stored for FFI error reporting."
        )?;
        writeln!(out, "        std::thread_local! {{")?;
        writeln!(
            out,
            "            static LAST_ERROR: std::cell::RefCell<Option<String>> = const {{ std::cell::RefCell::new(None) }};"
        )?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        // Error handling functions
        self.generate_ffi_error_functions(out, &prefix)?;

        // Generate extern "C" fns for each exported function
        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            self.generate_ffi_extern_function(out, ef)?;
        }

        writeln!(out, "    }};")?;
        writeln!(out, "}}")?;
        writeln!(out)?;

        // Backward-compatible alias
        writeln!(
            out,
            "/// Backward-compatible alias for [`witffi_register_ffi!`]."
        )?;
        writeln!(out, "#[macro_export]")?;
        writeln!(out, "macro_rules! witffi_register {{")?;
        writeln!(out, "    ($impl_type:ty) => {{")?;
        writeln!(out, "        witffi_register_ffi!($impl_type);")?;
        writeln!(out, "    }};")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    fn generate_ffi_shadow_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "        // ---- repr(C) shadow types for C-ABI ----")?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_ffi_shadow_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_ffi_shadow_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);

                writeln!(out, "        #[repr(C)]")?;
                writeln!(out, "        #[derive(Debug)]")?;
                writeln!(out, "        pub struct {c_name} {{")?;
                for field in &record.fields {
                    let field_name = names::to_rust_ident(&field.name);
                    let field_type = self.type_to_c_rust(&field.ty);
                    writeln!(out, "            pub {field_name}: {field_type},")?;
                }
                writeln!(out, "        }}")?;
                writeln!(out)?;
            }

            TypeDefKind::Variant(variant) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let tag_name = format!("{c_name}Tag");

                writeln!(out, "        #[repr(u32)]")?;
                writeln!(out, "        #[derive(Debug, Clone, Copy, PartialEq, Eq)]")?;
                writeln!(out, "        pub enum {tag_name} {{")?;
                for (i, case) in variant.cases.iter().enumerate() {
                    let variant_name = names::to_rust_type(&case.name);
                    writeln!(out, "            {variant_name} = {i},")?;
                }
                writeln!(out, "        }}")?;
                writeln!(out)?;

                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        writeln!(out, "        #[repr(C)]")?;
                        writeln!(out, "        #[derive(Debug)]")?;
                        writeln!(out, "        pub struct {payload_name} {{")?;
                        writeln!(out, "            pub value: {},", self.type_to_c_rust(ty))?;
                        writeln!(out, "        }}")?;
                        writeln!(out)?;
                    }
                }

                writeln!(out, "        #[repr(C)]")?;
                writeln!(out, "        #[derive(Debug)]")?;
                writeln!(out, "        pub struct {c_name} {{")?;
                writeln!(out, "            pub tag: {tag_name},")?;
                for case in &variant.cases {
                    let field_name = names::to_rust_ident(&case.name);
                    if case.ty.is_some() {
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        writeln!(out, "            pub {field_name}: *mut {payload_name},")?;
                    }
                }
                writeln!(out, "        }}")?;
                writeln!(out)?;
            }

            TypeDefKind::Enum(e) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                writeln!(out, "        #[repr(u32)]")?;
                writeln!(out, "        #[derive(Debug, Clone, Copy, PartialEq, Eq)]")?;
                writeln!(out, "        pub enum {c_name} {{")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let case_name = names::to_rust_type(&case.name);
                    writeln!(out, "            {case_name} = {i},")?;
                }
                writeln!(out, "        }}")?;
                writeln!(out)?;
            }

            TypeDefKind::Flags(flags) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                writeln!(out, "        pub type {c_name} = u32;")?;
                for (i, flag) in flags.flags.iter().enumerate() {
                    let const_name = names::to_c_enum_variant(wit_name, &flag.name);
                    writeln!(out, "        pub const {const_name}: {c_name} = 1 << {i};")?;
                }
                writeln!(out)?;
            }

            TypeDefKind::Type(inner) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let inner_ty = self.type_to_c_rust(inner);
                if c_name != inner_ty {
                    writeln!(out, "        pub type {c_name} = {inner_ty};")?;
                    writeln!(out)?;
                }
            }

            _ => {}
        }

        Ok(())
    }

    fn generate_ffi_conversions(&self, out: &mut String) -> std::fmt::Result {
        writeln!(
            out,
            "        // ---- Conversions: idiomatic -> repr(C) ----"
        )?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(record) => {
                    let rust_name = names::to_rust_type(wit_name);
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let fn_name = format!("{}_to_ffi", wit_name.to_snake_case());

                    writeln!(out, "        fn {fn_name}(v: {rust_name}) -> {c_name} {{")?;
                    writeln!(out, "            {c_name} {{")?;
                    for field in &record.fields {
                        let field_name = names::to_rust_ident(&field.name);
                        let conversion =
                            self.generate_to_ffi_expr(&field.ty, &format!("v.{field_name}"));
                        writeln!(out, "                {field_name}: {conversion},")?;
                    }
                    writeln!(out, "            }}")?;
                    writeln!(out, "        }}")?;
                    writeln!(out)?;
                }

                TypeDefKind::Variant(variant) => {
                    let rust_name = names::to_rust_type(wit_name);
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let tag_name = format!("{c_name}Tag");
                    let fn_name = format!("{}_to_ffi", wit_name.to_snake_case());

                    writeln!(out, "        fn {fn_name}(v: {rust_name}) -> {c_name} {{")?;
                    writeln!(out, "            match v {{")?;

                    // We need to build the match arms. Each arm sets the tag
                    // and assigns the active payload pointer; the others are null.
                    for (i, case) in variant.cases.iter().enumerate() {
                        let variant_name = names::to_rust_type(&case.name);
                        let tag_variant = format!("{tag_name}::{variant_name}");

                        if let Some(ty) = &case.ty {
                            let payload_name =
                                format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                            let conversion = self.generate_to_ffi_expr(ty, "inner");

                            writeln!(
                                out,
                                "                {rust_name}::{variant_name}(inner) => {c_name} {{"
                            )?;
                            writeln!(out, "                    tag: {tag_variant},")?;

                            // Set all case fields
                            for (j, other_case) in variant.cases.iter().enumerate() {
                                if other_case.ty.is_none() {
                                    continue;
                                }
                                let other_field = names::to_rust_ident(&other_case.name);
                                if j == i {
                                    writeln!(
                                        out,
                                        "                    {other_field}: Box::into_raw(Box::new({payload_name} {{ value: {conversion} }})),"
                                    )?;
                                } else {
                                    writeln!(
                                        out,
                                        "                    {other_field}: std::ptr::null_mut(),"
                                    )?;
                                }
                            }

                            writeln!(out, "                }},")?;
                        } else {
                            writeln!(
                                out,
                                "                {rust_name}::{variant_name} => {c_name} {{"
                            )?;
                            writeln!(out, "                    tag: {tag_variant},")?;
                            for other_case in &variant.cases {
                                if other_case.ty.is_some() {
                                    let other_field = names::to_rust_ident(&other_case.name);
                                    writeln!(
                                        out,
                                        "                    {other_field}: std::ptr::null_mut(),"
                                    )?;
                                }
                            }
                            writeln!(out, "                }},")?;
                        }
                    }

                    writeln!(out, "            }}")?;
                    writeln!(out, "        }}")?;
                    writeln!(out)?;
                }

                _ => {}
            }
        }

        Ok(())
    }

    /// Generate a Rust expression that converts an idiomatic value to its FFI representation.
    fn generate_to_ffi_expr(&self, ty: &Type, expr: &str) -> String {
        match ty {
            Type::String => format!("witffi_types::FfiByteBuffer::from_string({expr})"),
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => expr.to_string(),
            Type::Char => format!("{expr} as u32"),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("witffi_types::FfiByteBuffer::from_vec({expr})")
                    }
                    TypeDefKind::List(_) => {
                        // General list serialization â€” placeholder
                        format!(
                            "witffi_types::FfiByteBuffer::from_vec({expr}.into()) /* TODO: list serialization */"
                        )
                    }
                    TypeDefKind::Option(inner) => {
                        let inner_expr = self.generate_to_ffi_expr(inner, "v");
                        format!("witffi_types::option_to_ptr({expr}.map(|v| {inner_expr}))")
                    }
                    TypeDefKind::Type(aliased) => self.generate_to_ffi_expr(aliased, expr),
                    TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");
                        let fn_name = format!("{}_to_ffi", wit_name.to_snake_case());
                        format!("{fn_name}({expr})")
                    }
                    TypeDefKind::Enum(_) | TypeDefKind::Flags(_) => expr.to_string(),
                    _ => expr.to_string(),
                }
            }
            Type::ErrorContext => format!("{expr} as u32"),
        }
    }

    fn generate_ffi_free_functions(&self, out: &mut String) -> std::fmt::Result {
        let prefix = self.config.c_prefix.to_snake_case();

        writeln!(out, "        // ---- Free functions ----")?;
        writeln!(out)?;
        writeln!(out, "        #[allow(clippy::missing_safety_doc)]")?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub unsafe extern \"C\" fn {prefix}_free_byte_buffer(buf: witffi_types::FfiByteBuffer) {{"
        )?;
        writeln!(out, "            unsafe {{ buf.free() }};")?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let free_name =
                        names::to_c_func(&self.config.c_prefix, &format!("free-{wit_name}"));

                    writeln!(out, "        #[allow(clippy::missing_safety_doc)]")?;
                    writeln!(out, "        #[unsafe(no_mangle)]")?;
                    writeln!(
                        out,
                        "        pub unsafe extern \"C\" fn {free_name}(ptr: *mut {c_name}) {{"
                    )?;
                    writeln!(out, "            unsafe {{ witffi_types::free_ptr(ptr) }};")?;
                    writeln!(out, "        }}")?;
                    writeln!(out)?;
                }
                _ => {}
            }
        }

        Ok(())
    }

    fn generate_ffi_error_functions(&self, out: &mut String, prefix: &str) -> std::fmt::Result {
        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub extern \"C\" fn {prefix}_last_error_length() -> i32 {{"
        )?;
        writeln!(out, "            LAST_ERROR.with(|e| {{")?;
        writeln!(
            out,
            "                e.borrow().as_ref().map(|s| s.len() as i32 + 1).unwrap_or(0)"
        )?;
        writeln!(out, "            }})")?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        writeln!(out, "        #[allow(clippy::missing_safety_doc)]")?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub unsafe extern \"C\" fn {prefix}_error_message_utf8(buf: *mut std::os::raw::c_char, len: i32) -> i32 {{"
        )?;
        writeln!(out, "            LAST_ERROR.with(|e| {{")?;
        writeln!(out, "                match e.borrow().as_ref() {{")?;
        writeln!(out, "                    Some(msg) => {{")?;
        writeln!(
            out,
            "                        let c_msg = match std::ffi::CString::new(msg.as_str()) {{"
        )?;
        writeln!(out, "                            Ok(c) => c,")?;
        writeln!(out, "                            Err(_) => return -1,")?;
        writeln!(out, "                        }};")?;
        writeln!(
            out,
            "                        let bytes = c_msg.as_bytes_with_nul();"
        )?;
        writeln!(
            out,
            "                        let copy_len = bytes.len().min(len as usize);"
        )?;
        writeln!(
            out,
            "                        unsafe {{ std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf as *mut u8, copy_len) }};"
        )?;
        writeln!(out, "                        copy_len as i32")?;
        writeln!(out, "                    }}")?;
        writeln!(out, "                    None => 0,")?;
        writeln!(out, "                }}")?;
        writeln!(out, "            }})")?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub extern \"C\" fn {prefix}_clear_last_error() {{"
        )?;
        writeln!(
            out,
            "            LAST_ERROR.with(|e| *e.borrow_mut() = None);"
        )?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        Ok(())
    }

    fn generate_ffi_extern_function(
        &self,
        out: &mut String,
        ef: &ExportedFunction,
    ) -> std::fmt::Result {
        let c_func_name = if ef.interface_name.is_empty() {
            names::to_c_func(&self.config.c_prefix, &ef.function_name)
        } else {
            names::to_c_func(
                &self.config.c_prefix,
                &format!("{}-{}", ef.interface_name, ef.function_name),
            )
        };

        let trait_method = self.trait_method_name(ef);
        let result_decomposed = self.decompose_result(&ef.function.result);

        // Build C parameter list (using FFI-safe input types)
        let c_params: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                format!(
                    "{}: {}",
                    names::to_rust_ident(&p.name),
                    self.type_to_ffi_input(&p.ty)
                )
            })
            .collect();

        // Determine C return type
        let c_return = if let Some((ref ok_ty, _)) = result_decomposed {
            match ok_ty {
                Some(ty) => format!("*mut {}", self.type_to_c_rust(ty)),
                None => "bool".to_string(),
            }
        } else {
            match &ef.function.result {
                Some(ty) => self.type_to_c_rust(ty),
                None => "()".to_string(),
            }
        };

        writeln!(out, "        #[allow(clippy::missing_safety_doc)]")?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;

        if c_return == "()" {
            writeln!(
                out,
                "        pub unsafe extern \"C\" fn {c_func_name}({}) {{",
                c_params.join(", ")
            )?;
        } else {
            writeln!(
                out,
                "        pub unsafe extern \"C\" fn {c_func_name}({}) -> {c_return} {{",
                c_params.join(", ")
            )?;
        }

        writeln!(
            out,
            "            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {{"
        )?;

        // Convert parameters from FFI types to trait-compatible types
        for p in &ef.function.params {
            let c_name = names::to_rust_ident(&p.name);
            self.generate_param_conversion(out, &c_name, &p.ty, "                ")?;
        }

        let rust_args: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| format!("{}_rust", names::to_rust_ident(&p.name)))
            .collect();

        writeln!(
            out,
            "                <$impl_type>::{trait_method}({})",
            rust_args.join(", ")
        )?;
        writeln!(out, "            }}));")?;
        writeln!(out)?;

        // Handle the result - convert idiomatic return to FFI
        if let Some((ref ok_ty, _)) = result_decomposed {
            let has_ok_value = ok_ty.is_some();

            writeln!(out, "            match result {{")?;
            writeln!(out, "                Ok(Ok(value)) => {{")?;
            writeln!(
                out,
                "                    LAST_ERROR.with(|e| *e.borrow_mut() = None);"
            )?;
            if has_ok_value {
                let ok_type = ok_ty.as_ref().unwrap();
                let conversion = self.generate_to_ffi_expr(ok_type, "value");
                writeln!(
                    out,
                    "                    Box::into_raw(Box::new({conversion}))"
                )?;
            } else {
                writeln!(out, "                    true")?;
            }
            writeln!(out, "                }}")?;
            writeln!(out, "                Ok(Err(e)) => {{")?;
            writeln!(
                out,
                "                    LAST_ERROR.with(|e_cell| *e_cell.borrow_mut() = Some(format!(\"{{e}}\")));"
            )?;
            if has_ok_value {
                writeln!(out, "                    std::ptr::null_mut()")?;
            } else {
                writeln!(out, "                    false")?;
            }
            writeln!(out, "                }}")?;
            self.generate_panic_arm(out, has_ok_value)?;
            writeln!(out, "            }}")?;
        } else {
            writeln!(out, "            match result {{")?;
            writeln!(out, "                Ok(value) => {{")?;
            match &ef.function.result {
                Some(ty) => {
                    let conversion = self.generate_to_ffi_expr(ty, "value");
                    writeln!(out, "                    {conversion}")?;
                }
                None => {
                    writeln!(out, "                    value")?;
                }
            }
            writeln!(out, "                }}")?;
            self.generate_panic_arm(out, false)?;
            writeln!(out, "            }}")?;
        }

        writeln!(out, "        }}")?;
        writeln!(out)?;

        Ok(())
    }

    fn generate_panic_arm(&self, out: &mut String, has_value: bool) -> std::fmt::Result {
        writeln!(out, "                Err(panic) => {{")?;
        writeln!(
            out,
            "                    let msg = if let Some(s) = panic.downcast_ref::<&str>() {{"
        )?;
        writeln!(out, "                        s.to_string()")?;
        writeln!(
            out,
            "                    }} else if let Some(s) = panic.downcast_ref::<String>() {{"
        )?;
        writeln!(out, "                        s.clone()")?;
        writeln!(out, "                    }} else {{")?;
        writeln!(out, "                        \"unknown panic\".to_string()")?;
        writeln!(out, "                    }};")?;
        writeln!(
            out,
            "                    LAST_ERROR.with(|e| *e.borrow_mut() = Some(msg));"
        )?;
        if has_value {
            writeln!(out, "                    std::ptr::null_mut()")?;
        } else {
            writeln!(out, "                    Default::default()")?;
        }
        writeln!(out, "                }}")?;
        Ok(())
    }

    fn generate_param_conversion(
        &self,
        out: &mut String,
        c_name: &str,
        ty: &Type,
        indent: &str,
    ) -> std::fmt::Result {
        match ty {
            Type::String => {
                writeln!(
                    out,
                    "{indent}let {c_name}_rust = unsafe {{ {c_name}.as_str_unchecked() }};"
                )?;
            }
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => {
                writeln!(out, "{indent}let {c_name}_rust = {c_name};")?;
            }
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        writeln!(
                            out,
                            "{indent}let {c_name}_rust = unsafe {{ {c_name}.as_bytes() }};"
                        )?;
                    }
                    _ => {
                        writeln!(out, "{indent}let {c_name}_rust = {c_name};")?;
                    }
                }
            }
            _ => {
                writeln!(out, "{indent}let {c_name}_rust = {c_name};")?;
            }
        }
        Ok(())
    }

    // ---- witffi_register_jni! macro generation ----

    fn generate_register_jni_macro(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let trait_name = names::to_rust_type(&world.name);

        // Derive Kotlin package from WIT package name or config
        let kotlin_package = self
            .config
            .kotlin_package
            .clone()
            .unwrap_or_else(|| self.derive_kotlin_package());
        let jni_class_path = kotlin_package.replace('.', "/");
        let world_class = names::to_rust_type(&world.name);

        writeln!(out, "// ---- JNI Registration macro ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/// Register a concrete type for JNI (Kotlin/Android consumers)."
        )?;
        writeln!(out, "///")?;
        writeln!(
            out,
            "/// This macro generates `Java_` JNI entry points, JVM object"
        )?;
        writeln!(
            out,
            "/// construction helpers, and exception-based error handling."
        )?;
        writeln!(out, "///")?;
        writeln!(
            out,
            "/// Requires the `jni` crate as a dependency of the FFI crate."
        )?;
        writeln!(out, "///")?;
        writeln!(out, "/// # Example")?;
        writeln!(out, "///")?;
        writeln!(out, "/// ```ignore")?;
        writeln!(out, "/// struct MyImpl;")?;
        writeln!(out, "/// impl {trait_name} for MyImpl {{")?;
        writeln!(out, "///     // ... implement trait methods ...")?;
        writeln!(out, "/// }}")?;
        writeln!(out, "/// witffi_register_jni!(MyImpl);")?;
        writeln!(out, "/// ```")?;
        writeln!(out, "#[macro_export]")?;
        writeln!(out, "macro_rules! witffi_register_jni {{")?;
        writeln!(out, "    ($impl_type:ty) => {{")?;
        writeln!(out)?;

        // Generate JNI conversion helpers for each record/variant type
        self.generate_jni_conversion_helpers(out, &kotlin_package)?;

        // Generate JNI entry points
        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            self.generate_jni_entry_point(out, ef, &jni_class_path, &world_class)?;
        }

        writeln!(out, "    }};")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    fn derive_kotlin_package(&self) -> String {
        let world = &self.resolve.worlds[self.world_id];
        // Try to get the package name from the WIT world's package
        if let Some(pkg_id) = world.package {
            let pkg = &self.resolve.packages[pkg_id];
            let ns = &pkg.name.namespace;
            let name = &pkg.name.name;
            return format!("{ns}.{name}");
        }
        // Fallback to the world name
        world.name.clone()
    }

    fn generate_jni_conversion_helpers(
        &self,
        out: &mut String,
        kotlin_package: &str,
    ) -> std::fmt::Result {
        let jni_pkg = kotlin_package.replace('.', "/");

        writeln!(out, "        // ---- JNI conversion helpers ----")?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(record) => {
                    let rust_name = names::to_rust_type(wit_name);
                    let kotlin_name = names::to_kotlin_type(wit_name);
                    let fn_name = format!("to_jni_{}", wit_name.to_snake_case());
                    let class_path = format!("{jni_pkg}/{kotlin_name}");

                    writeln!(out, "        fn {fn_name}<'local>(")?;
                    writeln!(out, "            env: &mut jni::JNIEnv<'local>,")?;
                    writeln!(out, "            value: &{rust_name},")?;
                    writeln!(
                        out,
                        "        ) -> jni::errors::Result<jni::objects::JObject<'local>> {{"
                    )?;

                    // Build constructor args
                    for field in &record.fields {
                        let field_name = names::to_rust_ident(&field.name);
                        let jni_conv = self
                            .generate_to_jni_field_expr(&field.ty, &format!("value.{field_name}"));
                        writeln!(out, "            let _{field_name} = {jni_conv};")?;
                    }

                    // Build JNI descriptor
                    let descriptor = self.record_jni_constructor_descriptor(record, kotlin_package);

                    // Build JValue array
                    writeln!(out, "            let args: &[jni::objects::JValue] = &[")?;
                    for field in &record.fields {
                        let field_name = names::to_rust_ident(&field.name);
                        let jvalue = self.type_to_jvalue(&field.ty, &format!("_{field_name}"));
                        writeln!(out, "                {jvalue},")?;
                    }
                    writeln!(out, "            ];")?;

                    writeln!(
                        out,
                        "            env.new_object(\"{class_path}\", \"{descriptor}\", args)"
                    )?;
                    writeln!(out, "        }}")?;
                    writeln!(out)?;
                }

                TypeDefKind::Variant(variant) => {
                    let rust_name = names::to_rust_type(wit_name);
                    let kotlin_name = names::to_kotlin_type(wit_name);
                    let fn_name = format!("to_jni_{}", wit_name.to_snake_case());
                    let base_class_path = format!("{jni_pkg}/{kotlin_name}");

                    writeln!(out, "        fn {fn_name}<'local>(")?;
                    writeln!(out, "            env: &mut jni::JNIEnv<'local>,")?;
                    writeln!(out, "            value: &{rust_name},")?;
                    writeln!(
                        out,
                        "        ) -> jni::errors::Result<jni::objects::JObject<'local>> {{"
                    )?;
                    writeln!(out, "            match value {{")?;

                    for case in &variant.cases {
                        let case_name = names::to_rust_type(&case.name);
                        let kotlin_case = names::to_kotlin_type(&case.name);
                        let inner_class = format!("{base_class_path}${kotlin_case}");

                        if let Some(ty) = &case.ty {
                            let jni_conv = self.generate_to_jni_field_expr(ty, "inner");
                            let descriptor =
                                format!("({})V", self.type_to_jni_descriptor(ty, kotlin_package));
                            writeln!(out, "                {rust_name}::{case_name}(inner) => {{")?;
                            writeln!(out, "                    let _inner = {jni_conv};")?;
                            let jvalue = self.type_to_jvalue(ty, "_inner");
                            writeln!(
                                out,
                                "                    env.new_object(\"{inner_class}\", \"{descriptor}\", &[{jvalue}])"
                            )?;
                            writeln!(out, "                }}")?;
                        } else {
                            writeln!(out, "                {rust_name}::{case_name} => {{")?;
                            writeln!(
                                out,
                                "                    env.new_object(\"{inner_class}\", \"()V\", &[])"
                            )?;
                            writeln!(out, "                }}")?;
                        }
                    }

                    writeln!(out, "            }}")?;
                    writeln!(out, "        }}")?;
                    writeln!(out)?;
                }

                _ => {}
            }
        }

        Ok(())
    }

    /// Generate a JNI field expression for converting a Rust value.
    fn generate_to_jni_field_expr(&self, ty: &Type, expr: &str) -> String {
        match ty {
            Type::String => format!("env.new_string(&{expr})?"),
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => expr.to_string(),
            Type::Char => format!("{expr} as u16"),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("env.byte_array_from_slice(&{expr})?")
                    }
                    TypeDefKind::Option(inner) => {
                        let inner_expr = self.generate_to_jni_field_expr(inner, "v");
                        let is_primitive = self.is_jni_primitive(inner);
                        if is_primitive {
                            let boxed_class = self.type_to_jni_boxed_class(inner);
                            let box_descriptor = self.type_to_jni_box_descriptor(inner);
                            let jval = self.type_to_jvalue_primitive(inner, "v");
                            format!(
                                "match &{expr} {{ Some(v) => env.new_object(\"{boxed_class}\", \"{box_descriptor}\", &[{jval}])?, None => jni::objects::JObject::null() }}"
                            )
                        } else {
                            format!(
                                "match &{expr} {{ Some(v) => {{ let _v = {inner_expr}; jni::objects::JObject::from(_v) }}, None => jni::objects::JObject::null() }}"
                            )
                        }
                    }
                    TypeDefKind::Type(aliased) => self.generate_to_jni_field_expr(aliased, expr),
                    TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");
                        let fn_name = format!("to_jni_{}", wit_name.to_snake_case());
                        format!("{fn_name}(env, &{expr})?")
                    }
                    _ => expr.to_string(),
                }
            }
            Type::ErrorContext => format!("env.new_string(&{expr})?"),
        }
    }

    fn is_jni_primitive(&self, ty: &Type) -> bool {
        matches!(
            ty,
            Type::Bool
                | Type::U8
                | Type::U16
                | Type::U32
                | Type::U64
                | Type::S8
                | Type::S16
                | Type::S32
                | Type::S64
                | Type::F32
                | Type::F64
                | Type::Char
        )
    }

    fn type_to_jni_boxed_class(&self, ty: &Type) -> &'static str {
        match ty {
            Type::Bool => "java/lang/Boolean",
            Type::U8 | Type::S8 => "java/lang/Byte",
            Type::U16 | Type::S16 => "java/lang/Short",
            Type::U32 | Type::S32 => "java/lang/Integer",
            Type::U64 | Type::S64 => "java/lang/Long",
            Type::F32 => "java/lang/Float",
            Type::F64 => "java/lang/Double",
            Type::Char => "java/lang/Character",
            _ => "java/lang/Object",
        }
    }

    fn type_to_jni_box_descriptor(&self, ty: &Type) -> &'static str {
        match ty {
            Type::Bool => "(Z)V",
            Type::U8 | Type::S8 => "(B)V",
            Type::U16 | Type::S16 => "(S)V",
            Type::U32 | Type::S32 => "(I)V",
            Type::U64 | Type::S64 => "(J)V",
            Type::F32 => "(F)V",
            Type::F64 => "(D)V",
            Type::Char => "(C)V",
            _ => "(Ljava/lang/Object;)V",
        }
    }

    fn type_to_jvalue_primitive(&self, ty: &Type, expr: &str) -> String {
        match ty {
            Type::Bool => format!("jni::objects::JValue::Bool(*{expr} as u8)"),
            Type::U8 | Type::S8 => format!("jni::objects::JValue::Byte(*{expr} as i8)"),
            Type::U16 | Type::S16 => format!("jni::objects::JValue::Short(*{expr} as i16)"),
            Type::U32 | Type::S32 => format!("jni::objects::JValue::Int(*{expr} as i32)"),
            Type::U64 | Type::S64 => format!("jni::objects::JValue::Long(*{expr} as i64)"),
            Type::F32 => format!("jni::objects::JValue::Float(*{expr})"),
            Type::F64 => format!("jni::objects::JValue::Double(*{expr})"),
            Type::Char => format!("jni::objects::JValue::Char(*{expr} as u16)"),
            _ => "jni::objects::JValue::Object(&jni::objects::JObject::null())".to_string(),
        }
    }

    fn type_to_jvalue(&self, ty: &Type, expr: &str) -> String {
        match ty {
            Type::Bool => format!("jni::objects::JValue::Bool({expr} as u8)"),
            Type::U8 | Type::S8 => format!("jni::objects::JValue::Byte({expr} as i8)"),
            Type::U16 | Type::S16 => format!("jni::objects::JValue::Short({expr} as i16)"),
            Type::U32 | Type::S32 => format!("jni::objects::JValue::Int({expr} as i32)"),
            Type::U64 | Type::S64 => format!("jni::objects::JValue::Long({expr} as i64)"),
            Type::F32 => format!("jni::objects::JValue::Float({expr})"),
            Type::F64 => format!("jni::objects::JValue::Double({expr})"),
            Type::Char => format!("jni::objects::JValue::Char({expr} as u16)"),
            Type::String => format!("jni::objects::JValue::Object(&{expr})"),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("jni::objects::JValue::Object(&{expr})")
                    }
                    TypeDefKind::Option(_) => {
                        format!("jni::objects::JValue::Object(&{expr})")
                    }
                    TypeDefKind::Type(aliased) => self.type_to_jvalue(aliased, expr),
                    TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                        format!("jni::objects::JValue::Object(&{expr})")
                    }
                    _ => format!("jni::objects::JValue::Object(&{expr})"),
                }
            }
            Type::ErrorContext => format!("jni::objects::JValue::Object(&{expr})"),
        }
    }

    fn type_to_jni_descriptor(&self, ty: &Type, kotlin_package: &str) -> String {
        let jni_pkg = kotlin_package.replace('.', "/");
        match ty {
            Type::Bool => "Z".to_string(),
            Type::U8 | Type::S8 => "B".to_string(),
            Type::U16 | Type::S16 => "S".to_string(),
            Type::U32 | Type::S32 => "I".to_string(),
            Type::U64 | Type::S64 => "J".to_string(),
            Type::F32 => "F".to_string(),
            Type::F64 => "D".to_string(),
            Type::Char => "C".to_string(),
            Type::String => "Ljava/lang/String;".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "[B".to_string(),
                    TypeDefKind::List(_) => "[Ljava/lang/Object;".to_string(),
                    TypeDefKind::Option(inner) => {
                        if self.is_jni_primitive(inner) {
                            format!("L{};", self.type_to_jni_boxed_class(inner))
                        } else {
                            self.type_to_jni_descriptor(inner, kotlin_package)
                        }
                    }
                    TypeDefKind::Type(aliased) => {
                        self.type_to_jni_descriptor(aliased, kotlin_package)
                    }
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Object");
                        let kotlin_name = names::to_kotlin_type(name);
                        format!("L{jni_pkg}/{kotlin_name};")
                    }
                }
            }
            Type::ErrorContext => "Ljava/lang/String;".to_string(),
        }
    }

    fn record_jni_constructor_descriptor(
        &self,
        record: &wit_parser::Record,
        kotlin_package: &str,
    ) -> String {
        let params: Vec<String> = record
            .fields
            .iter()
            .map(|f| self.type_to_jni_descriptor(&f.ty, kotlin_package))
            .collect();
        format!("({})V", params.join(""))
    }

    fn generate_jni_entry_point(
        &self,
        out: &mut String,
        ef: &ExportedFunction,
        jni_class_path: &str,
        world_class: &str,
    ) -> std::fmt::Result {
        let trait_method = self.trait_method_name(ef);
        let result_decomposed = self.decompose_result(&ef.function.result);

        // Build the JNI function name
        // Convention: Java_{package}_{Class}_00024Companion_native{Method}
        let method_pascal = names::to_rust_type(&if ef.interface_name.is_empty() {
            ef.function_name.clone()
        } else {
            format!("{}-{}", ef.interface_name, ef.function_name)
        });
        let jni_func_name = format!(
            "Java_{}_{world_class}_00024Companion_native{method_pascal}",
            jni_class_path.replace('/', "_"),
        );

        // Build JNI parameter list
        let mut jni_params = vec![
            "mut env: jni::JNIEnv<'local>".to_string(),
            "_class: jni::objects::JClass<'local>".to_string(),
        ];
        for p in &ef.function.params {
            let name = names::to_rust_ident(&p.name);
            let jni_ty = self.type_to_jni_param_type(&p.ty);
            jni_params.push(format!("{name}: {jni_ty}"));
        }

        // Determine return type
        let jni_return = if result_decomposed.is_some() {
            "jni::sys::jobject".to_string()
        } else {
            match &ef.function.result {
                Some(ty) => self.type_to_jni_return_type(ty),
                None => "()".to_string(),
            }
        };

        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(out, "        pub extern \"C\" fn {jni_func_name}<'local>(")?;
        for param in &jni_params {
            writeln!(out, "            {param},")?;
        }
        if jni_return == "()" {
            writeln!(out, "        ) {{")?;
        } else {
            writeln!(out, "        ) -> {jni_return} {{")?;
        }

        writeln!(
            out,
            "            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {{"
        )?;

        // Convert JNI params to Rust types
        for p in &ef.function.params {
            let name = names::to_rust_ident(&p.name);
            self.generate_jni_param_conversion(out, &name, &p.ty)?;
        }

        let rust_args: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| format!("{}_rust", names::to_rust_ident(&p.name)))
            .collect();

        writeln!(
            out,
            "                <$impl_type>::{trait_method}({})",
            rust_args.join(", ")
        )?;
        writeln!(out, "            }}));")?;
        writeln!(out)?;

        // Handle result
        if let Some((ref ok_ty, _)) = result_decomposed {
            writeln!(out, "            match result {{")?;
            writeln!(out, "                Ok(Ok(value)) => {{")?;
            if let Some(ty) = ok_ty {
                let jni_conv = self.generate_to_jni_field_expr(ty, "value");
                writeln!(
                    out,
                    "                    match (|| -> jni::errors::Result<_> {{ Ok({jni_conv}) }})() {{"
                )?;
                writeln!(out, "                        Ok(obj) => obj.into_raw(),")?;
                writeln!(out, "                        Err(e) => {{")?;
                writeln!(
                    out,
                    "                            let _ = env.throw_new(\"java/lang/RuntimeException\", format!(\"{{e}}\"));"
                )?;
                writeln!(out, "                            std::ptr::null_mut()")?;
                writeln!(out, "                        }}")?;
                writeln!(out, "                    }}")?;
            } else {
                writeln!(out, "                    // void ok â€” no return value")?;
            }
            writeln!(out, "                }}")?;
            writeln!(out, "                Ok(Err(e)) => {{")?;
            writeln!(
                out,
                "                    let _ = env.throw_new(\"java/lang/RuntimeException\", format!(\"{{e}}\"));"
            )?;
            writeln!(out, "                    std::ptr::null_mut()")?;
            writeln!(out, "                }}")?;
            writeln!(out, "                Err(_panic) => {{")?;
            writeln!(
                out,
                "                    let _ = env.throw_new(\"java/lang/RuntimeException\", \"Rust panic\");"
            )?;
            writeln!(out, "                    std::ptr::null_mut()")?;
            writeln!(out, "                }}")?;
            writeln!(out, "            }}")?;
        } else {
            writeln!(out, "            match result {{")?;
            writeln!(out, "                Ok(value) => value,")?;
            writeln!(out, "                Err(_panic) => {{")?;
            writeln!(
                out,
                "                    let _ = env.throw_new(\"java/lang/RuntimeException\", \"Rust panic\");"
            )?;
            writeln!(out, "                    Default::default()")?;
            writeln!(out, "                }}")?;
            writeln!(out, "            }}")?;
        }

        writeln!(out, "        }}")?;
        writeln!(out)?;

        Ok(())
    }

    fn type_to_jni_param_type(&self, ty: &Type) -> String {
        match ty {
            Type::String => "jni::objects::JString<'local>".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "jni::objects::JByteArray<'local>".to_string(),
                    TypeDefKind::Type(aliased) => self.type_to_jni_param_type(aliased),
                    _ => "jni::objects::JObject<'local>".to_string(),
                }
            }
            Type::Bool => "jni::sys::jboolean".to_string(),
            Type::U8 | Type::S8 => "jni::sys::jbyte".to_string(),
            Type::U16 | Type::S16 => "jni::sys::jshort".to_string(),
            Type::U32 | Type::S32 => "jni::sys::jint".to_string(),
            Type::U64 | Type::S64 => "jni::sys::jlong".to_string(),
            Type::F32 => "jni::sys::jfloat".to_string(),
            Type::F64 => "jni::sys::jdouble".to_string(),
            _ => "jni::objects::JObject<'local>".to_string(),
        }
    }

    fn type_to_jni_return_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "jni::sys::jboolean".to_string(),
            Type::U8 | Type::S8 => "jni::sys::jbyte".to_string(),
            Type::U16 | Type::S16 => "jni::sys::jshort".to_string(),
            Type::U32 | Type::S32 => "jni::sys::jint".to_string(),
            Type::U64 | Type::S64 => "jni::sys::jlong".to_string(),
            Type::F32 => "jni::sys::jfloat".to_string(),
            Type::F64 => "jni::sys::jdouble".to_string(),
            _ => "jni::sys::jobject".to_string(),
        }
    }

    fn generate_jni_param_conversion(
        &self,
        out: &mut String,
        name: &str,
        ty: &Type,
    ) -> std::fmt::Result {
        match ty {
            Type::String => {
                writeln!(
                    out,
                    "                let {name}_rust: String = env.get_string(&{name}).map_err(|e| e.to_string())?.into();"
                )?;
            }
            Type::Bool => {
                writeln!(out, "                let {name}_rust = {name} != 0;")?;
            }
            Type::U8 => writeln!(out, "                let {name}_rust = {name} as u8;")?,
            Type::U16 => writeln!(out, "                let {name}_rust = {name} as u16;")?,
            Type::U32 => writeln!(out, "                let {name}_rust = {name} as u32;")?,
            Type::U64 => writeln!(out, "                let {name}_rust = {name} as u64;")?,
            Type::S8 => writeln!(out, "                let {name}_rust = {name} as i8;")?,
            Type::S16 => writeln!(out, "                let {name}_rust = {name} as i16;")?,
            Type::S32 => writeln!(out, "                let {name}_rust = {name} as i32;")?,
            Type::S64 => writeln!(out, "                let {name}_rust = {name} as i64;")?,
            Type::F32 | Type::F64 => {
                writeln!(out, "                let {name}_rust = {name};")?;
            }
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        writeln!(
                            out,
                            "                let {name}_rust = env.convert_byte_array(&{name}).map_err(|e| e.to_string())?;"
                        )?;
                    }
                    TypeDefKind::Type(aliased) => {
                        self.generate_jni_param_conversion(out, name, aliased)?;
                    }
                    _ => {
                        writeln!(out, "                let {name}_rust = {name};")?;
                    }
                }
            }
            _ => {
                writeln!(out, "                let {name}_rust = {name};")?;
            }
        }
        Ok(())
    }

    // ---- C header generation ----

    fn generate_c_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* ---- Types ---- */")?;
        writeln!(out)?;
        writeln!(
            out,
            "/* FfiByteSlice and FfiByteBuffer are provided by witffi_types.h */"
        )?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_c_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_c_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                writeln!(out, "typedef struct {{")?;
                for field in &record.fields {
                    let field_name = names::to_rust_ident(&field.name);
                    let field_type = self.type_to_c_header(&field.ty);
                    writeln!(out, "    {field_type} {field_name};")?;
                }
                writeln!(out, "}} {c_name};")?;
                writeln!(out)?;
            }

            TypeDefKind::Variant(variant) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let tag_name = format!("{c_name}Tag");

                writeln!(out, "typedef enum {{")?;
                for (i, case) in variant.cases.iter().enumerate() {
                    let variant_upper = names::to_c_enum_variant(&c_name, &case.name);
                    writeln!(out, "    {variant_upper} = {i},")?;
                }
                writeln!(out, "}} {tag_name};")?;
                writeln!(out)?;

                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        let value_type = self.type_to_c_header(ty);
                        writeln!(out, "typedef struct {{")?;
                        writeln!(out, "    {value_type} value;")?;
                        writeln!(out, "}} {payload_name};")?;
                        writeln!(out)?;
                    }
                }

                writeln!(out, "typedef struct {{")?;
                writeln!(out, "    {tag_name} tag;")?;
                for case in &variant.cases {
                    if case.ty.is_some() {
                        let field_name = names::to_rust_ident(&case.name);
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        writeln!(out, "    {payload_name} *{field_name};")?;
                    }
                }
                writeln!(out, "}} {c_name};")?;
                writeln!(out)?;
            }

            TypeDefKind::Enum(e) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                writeln!(out, "typedef enum {{")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let case_upper = names::to_c_enum_variant(&c_name, &case.name);
                    writeln!(out, "    {case_upper} = {i},")?;
                }
                writeln!(out, "}} {c_name};")?;
                writeln!(out)?;
            }

            TypeDefKind::Type(inner) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let inner_c = self.type_to_c_header(inner);
                if c_name != inner_c {
                    writeln!(out, "typedef {inner_c} {c_name};")?;
                    writeln!(out)?;
                }
            }

            _ => {}
        }

        Ok(())
    }

    fn type_to_c_header(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "uint8_t".to_string(),
            Type::U16 => "uint16_t".to_string(),
            Type::U32 => "uint32_t".to_string(),
            Type::U64 => "uint64_t".to_string(),
            Type::S8 => "int8_t".to_string(),
            Type::S16 => "int16_t".to_string(),
            Type::S32 => "int32_t".to_string(),
            Type::S64 => "int64_t".to_string(),
            Type::F32 => "float".to_string(),
            Type::F64 => "double".to_string(),
            Type::Char => "uint32_t".to_string(),
            Type::String => "FfiByteBuffer".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "FfiByteBuffer".to_string(),
                    TypeDefKind::List(_) => "FfiByteBuffer".to_string(),
                    TypeDefKind::Option(inner) => format!("{}*", self.type_to_c_header(inner)),
                    TypeDefKind::Type(aliased) => self.type_to_c_header(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("void");
                        names::to_c_type(&self.config.c_type_prefix, name)
                    }
                }
            }
            Type::ErrorContext => "uint32_t".to_string(),
        }
    }

    /// Map a WIT type to its C header input representation.
    fn type_to_c_header_input(&self, ty: &Type) -> String {
        match ty {
            Type::String => "FfiByteSlice".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "FfiByteSlice".to_string(),
                    TypeDefKind::List(_) => "FfiByteSlice".to_string(),
                    TypeDefKind::Type(aliased) => self.type_to_c_header_input(aliased),
                    _ => self.type_to_c_header(ty),
                }
            }
            _ => self.type_to_c_header(ty),
        }
    }

    fn generate_c_function_decls(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* ---- Functions ---- */")?;
        writeln!(out)?;

        let prefix = self.config.c_prefix.to_snake_case();
        writeln!(out, "int32_t {prefix}_last_error_length(void);")?;
        writeln!(
            out,
            "int32_t {prefix}_error_message_utf8(char *buf, int32_t len);"
        )?;
        writeln!(out, "void {prefix}_clear_last_error(void);")?;
        writeln!(out)?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            let c_func_name = if ef.interface_name.is_empty() {
                names::to_c_func(&self.config.c_prefix, &ef.function_name)
            } else {
                names::to_c_func(
                    &self.config.c_prefix,
                    &format!("{}-{}", ef.interface_name, ef.function_name),
                )
            };

            let result_decomposed = self.decompose_result(&ef.function.result);

            let c_params: Vec<String> = ef
                .function
                .params
                .iter()
                .map(|p| {
                    format!(
                        "{} {}",
                        self.type_to_c_header_input(&p.ty),
                        names::to_rust_ident(&p.name)
                    )
                })
                .collect();

            let c_return = if let Some((ref ok_ty, _)) = result_decomposed {
                match ok_ty {
                    Some(ty) => format!("{}*", self.type_to_c_header(ty)),
                    None => "bool".to_string(),
                }
            } else {
                match &ef.function.result {
                    Some(ty) => self.type_to_c_header(ty),
                    None => "void".to_string(),
                }
            };

            let params_str = if c_params.is_empty() {
                "void".to_string()
            } else {
                c_params.join(", ")
            };

            writeln!(out, "{c_return} {c_func_name}({params_str});")?;
        }

        Ok(())
    }

    fn generate_c_free_decls(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* ---- Free functions ---- */")?;
        writeln!(out)?;

        let prefix = self.config.c_prefix.to_snake_case();
        writeln!(out, "void {prefix}_free_byte_buffer(FfiByteBuffer buf);")?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let free_name =
                        names::to_c_func(&self.config.c_prefix, &format!("free-{wit_name}"));
                    writeln!(out, "void {free_name}({c_name} *ptr);")?;
                }
                _ => {}
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use witffi_core::load_wit;

    fn test_config() -> RustConfig {
        RustConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
            kotlin_package: Some("zcash.eip681".to_string()),
            library_name: Some("eip681ffi".to_string()),
        }
    }

    #[test]
    fn test_generate_rust_from_eip681() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = RustGenerator::new(&resolve, world_id, test_config());
        let code = generator.generate().expect("failed to generate Rust code");

        // Print first for debugging
        eprintln!("=== Generated Rust ===\n{code}");

        // Idiomatic types
        assert!(
            code.contains("pub struct NativeRequest"),
            "missing idiomatic NativeRequest struct"
        );
        assert!(
            code.contains("pub enum TransactionRequest"),
            "missing idiomatic TransactionRequest enum"
        );
        assert!(
            code.contains("pub schema_prefix: String,"),
            "idiomatic type should use String, not FfiByteBuffer"
        );
        assert!(
            code.contains("pub chain_id: Option<u64>,"),
            "idiomatic type should use Option<u64>"
        );

        // Trait uses idiomatic types
        assert!(code.contains("pub trait Eip681"), "missing trait Eip681");
        assert!(
            code.contains("fn parser_parse(input: &str) -> Result<TransactionRequest, String>"),
            "trait should return idiomatic TransactionRequest"
        );

        // FFI macro
        assert!(
            code.contains("macro_rules! witffi_register_ffi"),
            "missing witffi_register_ffi macro"
        );

        // JNI macro
        assert!(
            code.contains("macro_rules! witffi_register_jni"),
            "missing witffi_register_jni macro"
        );

        // Backward compat alias
        assert!(
            code.contains("macro_rules! witffi_register {"),
            "missing backward-compatible witffi_register alias"
        );

        // repr(C) types inside FFI macro
        assert!(
            code.contains("pub struct FfiNativeRequest"),
            "missing repr(C) FfiNativeRequest inside FFI macro"
        );
        assert!(
            code.contains("#[repr(C)]"),
            "missing repr(C) attribute inside FFI macro"
        );

        // Conversion functions inside FFI macro
        assert!(
            code.contains("fn native_request_to_ffi"),
            "missing native_request_to_ffi conversion"
        );
        assert!(
            code.contains("fn transaction_request_to_ffi"),
            "missing transaction_request_to_ffi conversion"
        );
    }

    #[test]
    fn test_generate_c_header_from_eip681() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = RustGenerator::new(&resolve, world_id, test_config());
        let header = generator
            .generate_c_header()
            .expect("failed to generate C header");

        eprintln!("=== Generated C header ===\n{header}");

        assert!(header.contains("#pragma once"), "missing pragma once");
        assert!(header.contains("FfiByteBuffer"), "missing FfiByteBuffer");
        assert!(header.contains("FfiByteSlice"), "missing FfiByteSlice");
        assert!(
            header.contains("zcash_eip681_parser_parse(FfiByteSlice input)"),
            "missing parser_parse or wrong param type"
        );
    }

    #[test]
    fn test_generate_jni_macro_content() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = RustGenerator::new(&resolve, world_id, test_config());
        let code = generator.generate().expect("failed to generate Rust code");

        // JNI conversion helpers
        assert!(
            code.contains("fn to_jni_native_request"),
            "missing to_jni_native_request helper"
        );
        assert!(
            code.contains("fn to_jni_transaction_request"),
            "missing to_jni_transaction_request helper"
        );

        // JNI entry point
        assert!(
            code.contains("Java_zcash_eip681_Eip681_00024Companion_nativeParserParse"),
            "missing JNI entry point function name"
        );

        // JNI error handling
        assert!(
            code.contains("java/lang/RuntimeException"),
            "missing RuntimeException in JNI error handling"
        );

        // JNI class paths
        assert!(
            code.contains("zcash/eip681/NativeRequest"),
            "missing JNI class path for NativeRequest"
        );
    }

    #[test]
    fn test_idiomatic_types_generated() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let generator = RustGenerator::new(&resolve, world_id, test_config());
        let code = generator.generate().expect("failed to generate Rust code");

        // Verify idiomatic types use Rust-native types, not FFI types
        assert!(
            code.contains("pub value_atomic: Option<Vec<u8>>,"),
            "idiomatic type should use Option<Vec<u8>>"
        );
        assert!(
            code.contains("pub display: String,"),
            "idiomatic type should use String"
        );

        // Variant should be a proper Rust enum
        assert!(
            code.contains("Native(NativeRequest),"),
            "variant should use idiomatic enum syntax"
        );
        assert!(
            code.contains("Erc20(Erc20Request),"),
            "variant should use idiomatic enum syntax"
        );
        assert!(
            code.contains("Unrecognised(String),"),
            "variant should use String for string payloads"
        );
    }
}
