//! Rust C-ABI scaffolding code generator.
//!
//! Walks the resolved WIT types and produces:
//! 1. `#[repr(C)]` types for all records, variants, enums
//! 2. A Rust trait with one method per exported function
//! 3. `extern "C"` wrapper functions that delegate to the trait
//! 4. `free_*` functions for heap-allocated return types
//! 5. A C header string

use std::collections::HashSet;
use std::fmt::Write;

use heck::ToSnakeCase;
use snafu::prelude::*;
use wit_parser::{Resolve, Type, TypeDefKind, TypeId, WorldId};

use witffi_core::{ExportedFunction, exported_functions, names};

/// Errors that can occur during Rust code generation.
#[derive(Debug, Snafu)]
pub enum Error {
    /// A write to the output buffer failed.
    #[snafu(display("code generation write error"))]
    Write { source: std::fmt::Error },
}

/// Configuration for the Rust generator.
#[derive(Debug, Clone)]
pub struct RustConfig {
    /// Prefix for C function names (e.g. "zcash_eip681").
    pub c_prefix: String,
    /// Prefix for C type names (e.g. "Ffi").
    pub c_type_prefix: String,
}

impl Default for RustConfig {
    fn default() -> Self {
        Self {
            c_prefix: "witffi".to_string(),
            c_type_prefix: "Ffi".to_string(),
        }
    }
}

/// Generates Rust scaffolding code from a resolved WIT world.
pub struct RustGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: RustConfig,
}

impl<'a> RustGenerator<'a> {
    pub fn new(resolve: &'a Resolve, world_id: WorldId, config: RustConfig) -> Self {
        Self {
            resolve,
            world_id,
            config,
        }
    }

    /// Generate all Rust scaffolding code.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    /// Generate a C header string.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate_c_header(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_c_header_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    fn generate_inner(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// Auto-generated by witffi. Do not edit.")?;
        writeln!(out)?;

        self.generate_types(out)?;
        self.generate_trait(out)?;
        self.generate_free_functions(out)?;
        self.generate_register_macro(out)?;

        Ok(())
    }

    fn generate_c_header_inner(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* Auto-generated by witffi. Do not edit. */")?;
        writeln!(out, "#pragma once")?;
        writeln!(out)?;
        writeln!(out, "#include <stdint.h>")?;
        writeln!(out, "#include <stdbool.h>")?;
        writeln!(out, "#include <stddef.h>")?;
        writeln!(out)?;
        writeln!(out, "#include \"witffi_types.h\"")?;
        writeln!(out)?;
        writeln!(out, "#ifdef __cplusplus")?;
        writeln!(out, "extern \"C\" {{")?;
        writeln!(out, "#endif")?;
        writeln!(out)?;

        self.generate_c_types(out)?;
        writeln!(out)?;
        self.generate_c_function_decls(out)?;
        writeln!(out)?;
        self.generate_c_free_decls(out)?;

        writeln!(out)?;
        writeln!(out, "#ifdef __cplusplus")?;
        writeln!(out, "}}")?;
        writeln!(out, "#endif")?;

        Ok(())
    }

    // ---- Helpers for collecting reachable types ----

    /// Collect all type IDs reachable from the world's exports,
    /// following type aliases and nested type references.
    fn collect_reachable_types(&self) -> Vec<TypeId> {
        let mut visited = HashSet::new();
        let mut order = Vec::new();

        let world = &self.resolve.worlds[self.world_id];
        for (_key, item) in &world.exports {
            if let wit_parser::WorldItem::Interface { id, .. } = item {
                let iface = &self.resolve.interfaces[*id];
                // Collect types directly defined/referenced in this interface
                for (_name, type_id) in &iface.types {
                    self.visit_type_id(*type_id, &mut visited, &mut order);
                }
                // Also collect types from function params and results
                for (_fname, func) in &iface.functions {
                    for p in &func.params {
                        self.visit_type(&p.ty, &mut visited, &mut order);
                    }
                    if let Some(ty) = &func.result {
                        self.visit_type(ty, &mut visited, &mut order);
                    }
                }
            }
        }

        order
    }

    fn visit_type_id(
        &self,
        type_id: TypeId,
        visited: &mut HashSet<TypeId>,
        order: &mut Vec<TypeId>,
    ) {
        if !visited.insert(type_id) {
            return;
        }

        let typedef = &self.resolve.types[type_id];

        // Visit child types first (depth-first) so dependencies come before dependents
        match &typedef.kind {
            TypeDefKind::Record(record) => {
                for field in &record.fields {
                    self.visit_type(&field.ty, visited, order);
                }
            }
            TypeDefKind::Variant(variant) => {
                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        self.visit_type(ty, visited, order);
                    }
                }
            }
            TypeDefKind::List(ty) | TypeDefKind::Option(ty) => {
                self.visit_type(ty, visited, order);
            }
            TypeDefKind::Result(r) => {
                if let Some(ok) = &r.ok {
                    self.visit_type(ok, visited, order);
                }
                if let Some(err) = &r.err {
                    self.visit_type(err, visited, order);
                }
            }
            TypeDefKind::Tuple(tuple) => {
                for ty in &tuple.types {
                    self.visit_type(ty, visited, order);
                }
            }
            TypeDefKind::Type(ty) => {
                self.visit_type(ty, visited, order);
            }
            _ => {}
        }

        order.push(type_id);
    }

    fn visit_type(&self, ty: &Type, visited: &mut HashSet<TypeId>, order: &mut Vec<TypeId>) {
        if let Type::Id(id) = ty {
            self.visit_type_id(*id, visited, order);
        }
    }

    // ---- Helpers for understanding function result types ----

    /// Check if a function's return type is `result<T, E>` at the top level.
    /// Returns `(Some(ok_type), Some(err_type))` if so.
    fn decompose_result(&self, result: &Option<Type>) -> Option<(Option<Type>, Option<Type>)> {
        match result {
            Some(Type::Id(id)) => {
                let typedef = &self.resolve.types[*id];
                if let TypeDefKind::Result(r) = &typedef.kind {
                    Some((r.ok, r.err))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    // ---- Type generation ----

    fn generate_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- FFI-safe types ----")?;
        writeln!(out, "//")?;
        writeln!(
            out,
            "// FfiByteSlice and FfiByteBuffer are provided by the `witffi-types` crate."
        )?;
        writeln!(out)?;

        // Collect all types reachable from exported interfaces (in dependency order)
        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "#[repr(C)]")?;
                writeln!(out, "#[derive(Debug)]")?;
                writeln!(out, "pub struct {c_name} {{")?;
                for field in &record.fields {
                    let field_name = names::to_rust_ident(&field.name);
                    let field_type = self.type_to_c_rust(&field.ty);
                    if let Some(docs) = &field.docs.contents {
                        writeln!(out, "    /// {docs}")?;
                    }
                    writeln!(out, "    pub {field_name}: {field_type},")?;
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Variant(variant) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let tag_name = format!("{c_name}Tag");

                writeln!(out, "#[repr(u32)]")?;
                writeln!(out, "#[derive(Debug, Clone, Copy, PartialEq, Eq)]")?;
                writeln!(out, "pub enum {tag_name} {{")?;
                for (i, case) in variant.cases.iter().enumerate() {
                    let variant_name = names::to_rust_type(&case.name);
                    writeln!(out, "    {variant_name} = {i},")?;
                }
                writeln!(out, "}}")?;
                writeln!(out)?;

                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        writeln!(out, "#[repr(C)]")?;
                        writeln!(out, "#[derive(Debug)]")?;
                        writeln!(out, "pub struct {payload_name} {{")?;
                        writeln!(out, "    pub value: {},", self.type_to_c_rust(ty))?;
                        writeln!(out, "}}")?;
                        writeln!(out)?;
                    }
                }

                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "#[repr(C)]")?;
                writeln!(out, "#[derive(Debug)]")?;
                writeln!(out, "pub struct {c_name} {{")?;
                writeln!(out, "    pub tag: {tag_name},")?;
                for case in &variant.cases {
                    let field_name = names::to_rust_ident(&case.name);
                    if case.ty.is_some() {
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        writeln!(
                            out,
                            "    /// Valid when tag == {tag_name}::{}",
                            names::to_rust_type(&case.name)
                        )?;
                        writeln!(out, "    pub {field_name}: *mut {payload_name},")?;
                    }
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Enum(e) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "#[repr(u32)]")?;
                writeln!(out, "#[derive(Debug, Clone, Copy, PartialEq, Eq)]")?;
                writeln!(out, "pub enum {c_name} {{")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let case_name = names::to_rust_type(&case.name);
                    writeln!(out, "    {case_name} = {i},")?;
                }
                writeln!(out, "}}")?;
                writeln!(out)?;
            }

            TypeDefKind::Flags(flags) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                if let Some(docs) = &typedef.docs.contents {
                    writeln!(out, "/// {docs}")?;
                }
                writeln!(out, "pub type {c_name} = u32;")?;
                for (i, flag) in flags.flags.iter().enumerate() {
                    let const_name = names::to_c_enum_variant(wit_name, &flag.name);
                    writeln!(out, "pub const {const_name}: {c_name} = 1 << {i};")?;
                }
                writeln!(out)?;
            }

            TypeDefKind::Type(inner) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let inner_ty = self.type_to_c_rust(inner);
                // Skip self-referential aliases (from `use` across interfaces)
                if c_name != inner_ty {
                    writeln!(out, "pub type {c_name} = {inner_ty};")?;
                    writeln!(out)?;
                }
            }

            TypeDefKind::List(_)
            | TypeDefKind::Option(_)
            | TypeDefKind::Result(_)
            | TypeDefKind::Tuple(_) => {
                // Handled inline when they appear as field/param types
            }

            other => {
                writeln!(
                    out,
                    "// TODO: generate type for {wit_name} (kind: {})",
                    other.as_str()
                )?;
            }
        }

        Ok(())
    }

    /// Map a WIT type to its Rust FFI-safe representation.
    fn type_to_c_rust(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::S8 => "i8".to_string(),
            Type::S16 => "i16".to_string(),
            Type::S32 => "i32".to_string(),
            Type::S64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::Char => "u32".to_string(),
            Type::String => "witffi_types::FfiByteBuffer".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(inner) => match inner {
                        Type::U8 => "witffi_types::FfiByteBuffer".to_string(),
                        _ => format!(
                            "witffi_types::FfiByteBuffer /* list<{}> */",
                            self.type_to_c_rust(inner)
                        ),
                    },
                    TypeDefKind::Option(inner) => {
                        // All options become nullable pointers to a heap-allocated value.
                        // For primitives, we box them. For complex types, they're already pointers.
                        format!("*mut {}", self.type_to_c_rust(inner))
                    }
                    TypeDefKind::Result(result) => {
                        let ok_ty = result
                            .ok
                            .as_ref()
                            .map(|t| self.type_to_c_rust(t))
                            .unwrap_or_else(|| "()".to_string());
                        format!("/* result<{ok_ty}, ...> */")
                    }
                    TypeDefKind::Tuple(tuple) => {
                        let types: Vec<String> =
                            tuple.types.iter().map(|t| self.type_to_c_rust(t)).collect();
                        format!("/* tuple<{}> */", types.join(", "))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_c_rust(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        names::to_c_type(&self.config.c_type_prefix, name)
                    }
                }
            }
            Type::ErrorContext => "u32 /* error-context */".to_string(),
        }
    }

    // ---- Trait generation ----

    fn generate_trait(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let trait_name = names::to_rust_type(&world.name);

        writeln!(out, "// ---- Implementation trait ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/// Trait that library authors implement to provide the FFI functions."
        )?;
        writeln!(
            out,
            "/// Each method corresponds to a WIT exported function."
        )?;
        writeln!(out, "pub trait {trait_name} {{")?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            let method_name = self.trait_method_name(ef);

            let params: Vec<String> = ef
                .function
                .params
                .iter()
                .map(|p| {
                    format!(
                        "{}: {}",
                        names::to_rust_ident(&p.name),
                        self.type_to_trait_param(&p.ty)
                    )
                })
                .collect();

            let ret = self.function_return_to_trait(&ef.function.result);

            writeln!(out, "    fn {method_name}({}) -> {ret};", params.join(", "))?;
        }

        writeln!(out, "}}")?;
        Ok(())
    }

    fn trait_method_name(&self, ef: &ExportedFunction) -> String {
        if ef.interface_name.is_empty() {
            names::to_rust_ident(&ef.function_name)
        } else {
            names::to_rust_ident(&format!("{}-{}", ef.interface_name, ef.function_name))
        }
    }

    /// Map a WIT type to its Rust representation for trait method parameters.
    ///
    /// Parameters use borrowed types where possible: `&str` for strings,
    /// `&[u8]` for byte slices. Complex types use the generated FFI types.
    fn type_to_trait_param(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::S8 => "i8".to_string(),
            Type::S16 => "i16".to_string(),
            Type::S32 => "i32".to_string(),
            Type::S64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::Char => "char".to_string(),
            Type::String => "&str".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "&[u8]".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("Vec<{}>", self.type_to_trait_param(inner))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_trait_param(aliased),
                    _ => self.type_to_c_rust(ty),
                }
            }
            Type::ErrorContext => "String".to_string(),
        }
    }

    /// Map a WIT type to its Rust representation for trait method return types.
    ///
    /// Return types use owned types: the generated FFI `repr(C)` structs for
    /// complex types, `String` for WIT strings, and `Result<T, String>` for
    /// WIT `result<T, string>`.
    fn type_to_trait_return(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "u8".to_string(),
            Type::U16 => "u16".to_string(),
            Type::U32 => "u32".to_string(),
            Type::U64 => "u64".to_string(),
            Type::S8 => "i8".to_string(),
            Type::S16 => "i16".to_string(),
            Type::S32 => "i32".to_string(),
            Type::S64 => "i64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::Char => "char".to_string(),
            Type::String => "String".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "Vec<u8>".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("Vec<{}>", self.type_to_trait_return(inner))
                    }
                    TypeDefKind::Option(inner) => {
                        format!("Option<{}>", self.type_to_trait_return(inner))
                    }
                    TypeDefKind::Result(r) => {
                        let ok_ty =
                            r.ok.as_ref()
                                .map(|t| self.type_to_trait_return(t))
                                .unwrap_or_else(|| "()".to_string());
                        let err_ty = r
                            .err
                            .as_ref()
                            .map(|t| self.type_to_trait_return(t))
                            .unwrap_or_else(|| "()".to_string());
                        format!("Result<{ok_ty}, {err_ty}>")
                    }
                    TypeDefKind::Type(aliased) => self.type_to_trait_return(aliased),
                    _ => {
                        // Use the FFI repr(C) type name
                        self.type_to_c_rust(ty)
                    }
                }
            }
            Type::ErrorContext => "String".to_string(),
        }
    }

    fn function_return_to_trait(&self, result: &Option<Type>) -> String {
        match result {
            Some(ty) => self.type_to_trait_return(ty),
            None => "()".to_string(),
        }
    }

    // ---- Registration macro generation ----

    fn generate_register_macro(&self, out: &mut String) -> std::fmt::Result {
        let world = &self.resolve.worlds[self.world_id];
        let trait_name = names::to_rust_type(&world.name);
        let prefix = self.config.c_prefix.to_snake_case();

        writeln!(out, "// ---- Registration macro ----")?;
        writeln!(out)?;
        writeln!(
            out,
            "/// Register a concrete type that implements the [`{trait_name}`] trait."
        )?;
        writeln!(out, "///")?;
        writeln!(
            out,
            "/// This macro generates all `extern \"C\"` FFI functions that delegate"
        )?;
        writeln!(
            out,
            "/// to the trait implementation, handling parameter conversion, error"
        )?;
        writeln!(out, "/// storage, and panic catching.")?;
        writeln!(out, "///")?;
        writeln!(out, "/// # Example")?;
        writeln!(out, "///")?;
        writeln!(out, "/// ```ignore")?;
        writeln!(out, "/// struct MyImpl;")?;
        writeln!(out, "/// impl {trait_name} for MyImpl {{")?;
        writeln!(out, "///     // ... implement trait methods ...")?;
        writeln!(out, "/// }}")?;
        writeln!(out, "/// witffi_register!(MyImpl);")?;
        writeln!(out, "/// ```")?;
        writeln!(out, "#[macro_export]")?;
        writeln!(out, "macro_rules! witffi_register {{")?;
        writeln!(out, "    ($impl_type:ty) => {{")?;
        writeln!(out)?;

        // Thread-local error storage
        writeln!(
            out,
            "        // Last error message stored for FFI error reporting."
        )?;
        writeln!(out, "        std::thread_local! {{")?;
        writeln!(
            out,
            "            static LAST_ERROR: std::cell::RefCell<Option<String>> = const {{ std::cell::RefCell::new(None) }};"
        )?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        // Error handling functions
        writeln!(
            out,
            "        // Get the length of the last error message (0 if no error)."
        )?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub extern \"C\" fn {prefix}_last_error_length() -> i32 {{"
        )?;
        writeln!(out, "            LAST_ERROR.with(|e| {{")?;
        writeln!(
            out,
            "                e.borrow().as_ref().map(|s| s.len() as i32 + 1).unwrap_or(0)"
        )?;
        writeln!(out, "            }})")?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        writeln!(
            out,
            "        // Copy the last error message into the provided buffer."
        )?;
        writeln!(
            out,
            "        // Safety: `buf` must point to `len` bytes of writable memory."
        )?;
        writeln!(out, "        #[allow(clippy::missing_safety_doc)]")?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub unsafe extern \"C\" fn {prefix}_error_message_utf8(buf: *mut std::os::raw::c_char, len: i32) -> i32 {{"
        )?;
        writeln!(out, "            LAST_ERROR.with(|e| {{")?;
        writeln!(out, "                match e.borrow().as_ref() {{")?;
        writeln!(out, "                    Some(msg) => {{")?;
        writeln!(
            out,
            "                        let c_msg = match std::ffi::CString::new(msg.as_str()) {{"
        )?;
        writeln!(out, "                            Ok(c) => c,")?;
        writeln!(out, "                            Err(_) => return -1,")?;
        writeln!(out, "                        }};")?;
        writeln!(
            out,
            "                        let bytes = c_msg.as_bytes_with_nul();"
        )?;
        writeln!(
            out,
            "                        let copy_len = bytes.len().min(len as usize);"
        )?;
        writeln!(
            out,
            "                        unsafe {{ std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf as *mut u8, copy_len) }};"
        )?;
        writeln!(out, "                        copy_len as i32")?;
        writeln!(out, "                    }}")?;
        writeln!(out, "                    None => 0,")?;
        writeln!(out, "                }}")?;
        writeln!(out, "            }})")?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        writeln!(out, "        // Clear the last error.")?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "        pub extern \"C\" fn {prefix}_clear_last_error() {{"
        )?;
        writeln!(
            out,
            "            LAST_ERROR.with(|e| *e.borrow_mut() = None);"
        )?;
        writeln!(out, "        }}")?;
        writeln!(out)?;

        // Generate extern "C" fns for each exported function
        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            self.generate_macro_ffi_function(out, ef)?;
        }

        writeln!(out, "    }};")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    fn generate_macro_ffi_function(
        &self,
        out: &mut String,
        ef: &ExportedFunction,
    ) -> std::fmt::Result {
        let c_func_name = if ef.interface_name.is_empty() {
            names::to_c_func(&self.config.c_prefix, &ef.function_name)
        } else {
            names::to_c_func(
                &self.config.c_prefix,
                &format!("{}-{}", ef.interface_name, ef.function_name),
            )
        };

        let trait_method = self.trait_method_name(ef);

        // Check if the return type is result<T, E>
        let result_decomposed = self.decompose_result(&ef.function.result);

        // Build C parameter list (using FFI-safe input types)
        let c_params: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                format!(
                    "{}: {}",
                    names::to_rust_ident(&p.name),
                    self.type_to_ffi_input(&p.ty)
                )
            })
            .collect();

        // Determine C return type
        let c_return = if let Some((ref ok_ty, _)) = result_decomposed {
            match ok_ty {
                Some(ty) => format!("*mut {}", self.type_to_c_rust(ty)),
                None => "bool".to_string(),
            }
        } else {
            match &ef.function.result {
                Some(ty) => self.type_to_c_rust(ty),
                None => "()".to_string(),
            }
        };

        writeln!(
            out,
            "        // FFI wrapper for `{}.{}`.",
            ef.interface_name, ef.function_name
        )?;
        writeln!(
            out,
            "        // Safety: All pointer parameters must be valid for the given lengths."
        )?;
        writeln!(out, "        #[allow(clippy::missing_safety_doc)]")?;
        writeln!(out, "        #[unsafe(no_mangle)]")?;

        if c_return == "()" {
            writeln!(
                out,
                "        pub unsafe extern \"C\" fn {c_func_name}({}) {{",
                c_params.join(", ")
            )?;
        } else {
            writeln!(
                out,
                "        pub unsafe extern \"C\" fn {c_func_name}({}) -> {c_return} {{",
                c_params.join(", ")
            )?;
        }

        // Convert parameters from FFI types to trait-compatible types
        writeln!(
            out,
            "            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {{"
        )?;

        for p in &ef.function.params {
            let c_name = names::to_rust_ident(&p.name);
            self.generate_param_conversion(out, &c_name, &p.ty, "                ")?;
        }

        // Call the trait method on the concrete $impl_type
        let rust_args: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| format!("{}_rust", names::to_rust_ident(&p.name)))
            .collect();

        writeln!(
            out,
            "                <$impl_type>::{trait_method}({})",
            rust_args.join(", ")
        )?;
        writeln!(out, "            }}));")?;
        writeln!(out)?;

        // Handle the result
        if result_decomposed.is_some() {
            let has_ok_value = result_decomposed
                .as_ref()
                .map(|(ok, _)| ok.is_some())
                .unwrap_or(false);

            writeln!(out, "            match result {{")?;
            writeln!(out, "                Ok(Ok(value)) => {{")?;
            writeln!(
                out,
                "                    LAST_ERROR.with(|e| *e.borrow_mut() = None);"
            )?;
            if has_ok_value {
                writeln!(out, "                    Box::into_raw(Box::new(value))")?;
            } else {
                writeln!(out, "                    true")?;
            }
            writeln!(out, "                }}")?;
            writeln!(out, "                Ok(Err(e)) => {{")?;
            writeln!(
                out,
                "                    LAST_ERROR.with(|e_cell| *e_cell.borrow_mut() = Some(format!(\"{{e}}\")));"
            )?;
            if has_ok_value {
                writeln!(out, "                    std::ptr::null_mut()")?;
            } else {
                writeln!(out, "                    false")?;
            }
            writeln!(out, "                }}")?;
            writeln!(out, "                Err(panic) => {{")?;
            writeln!(
                out,
                "                    let msg = if let Some(s) = panic.downcast_ref::<&str>() {{"
            )?;
            writeln!(out, "                        s.to_string()")?;
            writeln!(
                out,
                "                    }} else if let Some(s) = panic.downcast_ref::<String>() {{"
            )?;
            writeln!(out, "                        s.clone()")?;
            writeln!(out, "                    }} else {{")?;
            writeln!(out, "                        \"unknown panic\".to_string()")?;
            writeln!(out, "                    }};")?;
            writeln!(
                out,
                "                    LAST_ERROR.with(|e| *e.borrow_mut() = Some(msg));"
            )?;
            if has_ok_value {
                writeln!(out, "                    std::ptr::null_mut()")?;
            } else {
                writeln!(out, "                    false")?;
            }
            writeln!(out, "                }}")?;
            writeln!(out, "            }}")?;
        } else {
            writeln!(out, "            match result {{")?;
            writeln!(out, "                Ok(value) => value,")?;
            writeln!(out, "                Err(panic) => {{")?;
            writeln!(
                out,
                "                    let msg = if let Some(s) = panic.downcast_ref::<&str>() {{"
            )?;
            writeln!(out, "                        s.to_string()")?;
            writeln!(
                out,
                "                    }} else if let Some(s) = panic.downcast_ref::<String>() {{"
            )?;
            writeln!(out, "                        s.clone()")?;
            writeln!(out, "                    }} else {{")?;
            writeln!(out, "                        \"unknown panic\".to_string()")?;
            writeln!(out, "                    }};")?;
            writeln!(
                out,
                "                    LAST_ERROR.with(|e| *e.borrow_mut() = Some(msg));"
            )?;
            writeln!(out, "                    Default::default()")?;
            writeln!(out, "                }}")?;
            writeln!(out, "            }}")?;
        }

        writeln!(out, "        }}")?;
        writeln!(out)?;

        Ok(())
    }

    /// Map a WIT type to its FFI-safe input representation.
    ///
    /// Input types differ from output types: strings and byte slices use
    /// `FfiByteSlice` (const pointer, caller-owned) rather than `FfiByteBuffer`
    /// (mutable pointer, callee-owned).
    fn type_to_ffi_input(&self, ty: &Type) -> String {
        match ty {
            Type::String => "witffi_types::FfiByteSlice".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "witffi_types::FfiByteSlice".to_string(),
                    TypeDefKind::List(_) => "witffi_types::FfiByteSlice".to_string(),
                    TypeDefKind::Type(aliased) => self.type_to_ffi_input(aliased),
                    _ => self.type_to_c_rust(ty),
                }
            }
            _ => self.type_to_c_rust(ty),
        }
    }

    fn generate_param_conversion(
        &self,
        out: &mut String,
        c_name: &str,
        ty: &Type,
        indent: &str,
    ) -> std::fmt::Result {
        match ty {
            Type::String => {
                writeln!(
                    out,
                    "{indent}let {c_name}_rust = unsafe {{ {c_name}.as_str_unchecked() }};"
                )?;
            }
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => {
                writeln!(out, "{indent}let {c_name}_rust = {c_name};")?;
            }
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        writeln!(
                            out,
                            "{indent}let {c_name}_rust = unsafe {{ {c_name}.as_bytes() }};"
                        )?;
                    }
                    _ => {
                        writeln!(out, "{indent}let {c_name}_rust = {c_name};")?;
                    }
                }
            }
            _ => {
                writeln!(out, "{indent}let {c_name}_rust = {c_name};")?;
            }
        }
        Ok(())
    }

    // ---- Free function generation ----

    fn generate_free_functions(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- Free functions ----")?;
        writeln!(out)?;

        let prefix = self.config.c_prefix.to_snake_case();

        writeln!(
            out,
            "/// Free an `FfiByteBuffer` returned by an FFI function."
        )?;
        writeln!(out, "///")?;
        writeln!(out, "/// # Safety")?;
        writeln!(
            out,
            "/// The buffer must have been allocated by this library."
        )?;
        writeln!(out, "#[unsafe(no_mangle)]")?;
        writeln!(
            out,
            "pub unsafe extern \"C\" fn {prefix}_free_byte_buffer(buf: witffi_types::FfiByteBuffer) {{"
        )?;
        writeln!(out, "    unsafe {{ buf.free() }};")?;
        writeln!(out, "}}")?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let free_name =
                        names::to_c_func(&self.config.c_prefix, &format!("free-{wit_name}"));

                    writeln!(out, "/// Free a `{c_name}` returned by an FFI function.")?;
                    writeln!(out, "///")?;
                    writeln!(out, "/// # Safety")?;
                    writeln!(
                        out,
                        "/// The pointer must have been allocated by this library."
                    )?;
                    writeln!(out, "#[unsafe(no_mangle)]")?;
                    writeln!(
                        out,
                        "pub unsafe extern \"C\" fn {free_name}(ptr: *mut {c_name}) {{"
                    )?;
                    writeln!(out, "    unsafe {{ witffi_types::free_ptr(ptr) }};")?;
                    writeln!(out, "}}")?;
                    writeln!(out)?;
                }
                _ => {}
            }
        }

        Ok(())
    }

    // ---- C header generation ----

    fn generate_c_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* ---- Types ---- */")?;
        writeln!(out)?;
        writeln!(
            out,
            "/* FfiByteSlice and FfiByteBuffer are provided by witffi_types.h */"
        )?;
        writeln!(out)?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_c_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_c_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                writeln!(out, "typedef struct {{")?;
                for field in &record.fields {
                    let field_name = names::to_rust_ident(&field.name);
                    let field_type = self.type_to_c_header(&field.ty);
                    writeln!(out, "    {field_type} {field_name};")?;
                }
                writeln!(out, "}} {c_name};")?;
                writeln!(out)?;
            }

            TypeDefKind::Variant(variant) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let tag_name = format!("{c_name}Tag");

                writeln!(out, "typedef enum {{")?;
                for (i, case) in variant.cases.iter().enumerate() {
                    let variant_upper = names::to_c_enum_variant(&c_name, &case.name);
                    writeln!(out, "    {variant_upper} = {i},")?;
                }
                writeln!(out, "}} {tag_name};")?;
                writeln!(out)?;

                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        let value_type = self.type_to_c_header(ty);
                        writeln!(out, "typedef struct {{")?;
                        writeln!(out, "    {value_type} value;")?;
                        writeln!(out, "}} {payload_name};")?;
                        writeln!(out)?;
                    }
                }

                writeln!(out, "typedef struct {{")?;
                writeln!(out, "    {tag_name} tag;")?;
                for case in &variant.cases {
                    if case.ty.is_some() {
                        let field_name = names::to_rust_ident(&case.name);
                        let payload_name =
                            format!("{c_name}{}Payload", names::to_rust_type(&case.name));
                        writeln!(out, "    {payload_name} *{field_name};")?;
                    }
                }
                writeln!(out, "}} {c_name};")?;
                writeln!(out)?;
            }

            TypeDefKind::Enum(e) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                writeln!(out, "typedef enum {{")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let case_upper = names::to_c_enum_variant(&c_name, &case.name);
                    writeln!(out, "    {case_upper} = {i},")?;
                }
                writeln!(out, "}} {c_name};")?;
                writeln!(out)?;
            }

            TypeDefKind::Type(inner) => {
                let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                let inner_c = self.type_to_c_header(inner);
                // Skip self-referential aliases (from `use` across interfaces)
                if c_name != inner_c {
                    writeln!(out, "typedef {inner_c} {c_name};")?;
                    writeln!(out)?;
                }
            }

            _ => {}
        }

        Ok(())
    }

    fn type_to_c_header(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "uint8_t".to_string(),
            Type::U16 => "uint16_t".to_string(),
            Type::U32 => "uint32_t".to_string(),
            Type::U64 => "uint64_t".to_string(),
            Type::S8 => "int8_t".to_string(),
            Type::S16 => "int16_t".to_string(),
            Type::S32 => "int32_t".to_string(),
            Type::S64 => "int64_t".to_string(),
            Type::F32 => "float".to_string(),
            Type::F64 => "double".to_string(),
            Type::Char => "uint32_t".to_string(),
            Type::String => "FfiByteBuffer".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "FfiByteBuffer".to_string(),
                    TypeDefKind::List(_) => "FfiByteBuffer".to_string(),
                    TypeDefKind::Option(inner) => format!("{}*", self.type_to_c_header(inner)),
                    TypeDefKind::Type(aliased) => self.type_to_c_header(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("void");
                        names::to_c_type(&self.config.c_type_prefix, name)
                    }
                }
            }
            Type::ErrorContext => "uint32_t".to_string(),
        }
    }

    /// Map a WIT type to its C header input representation.
    ///
    /// Input parameters use `FfiByteSlice` (const pointer) for strings
    /// and byte slices, since the caller owns the data.
    fn type_to_c_header_input(&self, ty: &Type) -> String {
        match ty {
            Type::String => "FfiByteSlice".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "FfiByteSlice".to_string(),
                    TypeDefKind::List(_) => "FfiByteSlice".to_string(),
                    TypeDefKind::Type(aliased) => self.type_to_c_header_input(aliased),
                    _ => self.type_to_c_header(ty),
                }
            }
            _ => self.type_to_c_header(ty),
        }
    }

    fn generate_c_function_decls(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* ---- Functions ---- */")?;
        writeln!(out)?;

        let prefix = self.config.c_prefix.to_snake_case();
        writeln!(out, "int32_t {prefix}_last_error_length(void);")?;
        writeln!(
            out,
            "int32_t {prefix}_error_message_utf8(char *buf, int32_t len);"
        )?;
        writeln!(out, "void {prefix}_clear_last_error(void);")?;
        writeln!(out)?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            let c_func_name = if ef.interface_name.is_empty() {
                names::to_c_func(&self.config.c_prefix, &ef.function_name)
            } else {
                names::to_c_func(
                    &self.config.c_prefix,
                    &format!("{}-{}", ef.interface_name, ef.function_name),
                )
            };

            let result_decomposed = self.decompose_result(&ef.function.result);

            let c_params: Vec<String> = ef
                .function
                .params
                .iter()
                .map(|p| {
                    format!(
                        "{} {}",
                        self.type_to_c_header_input(&p.ty),
                        names::to_rust_ident(&p.name)
                    )
                })
                .collect();

            let c_return = if let Some((ref ok_ty, _)) = result_decomposed {
                match ok_ty {
                    Some(ty) => format!("{}*", self.type_to_c_header(ty)),
                    None => "bool".to_string(),
                }
            } else {
                match &ef.function.result {
                    Some(ty) => self.type_to_c_header(ty),
                    None => "void".to_string(),
                }
            };

            let params_str = if c_params.is_empty() {
                "void".to_string()
            } else {
                c_params.join(", ")
            };

            writeln!(out, "{c_return} {c_func_name}({params_str});")?;
        }

        Ok(())
    }

    fn generate_c_free_decls(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "/* ---- Free functions ---- */")?;
        writeln!(out)?;

        let prefix = self.config.c_prefix.to_snake_case();
        writeln!(out, "void {prefix}_free_byte_buffer(FfiByteBuffer buf);")?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let free_name =
                        names::to_c_func(&self.config.c_prefix, &format!("free-{wit_name}"));
                    writeln!(out, "void {free_name}({c_name} *ptr);")?;
                }
                _ => {}
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use witffi_core::load_wit;

    #[test]
    fn test_generate_rust_from_eip681() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let config = RustConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };

        let generator = RustGenerator::new(&resolve, world_id, config);
        let code = generator.generate().expect("failed to generate Rust code");

        // Print first for debugging
        eprintln!("=== Generated Rust ===\n{code}");

        // Verify key elements are present
        assert!(
            code.contains("witffi_types::FfiByteBuffer"),
            "missing witffi_types::FfiByteBuffer reference"
        );
        assert!(
            code.contains("witffi_types::FfiByteSlice"),
            "missing witffi_types::FfiByteSlice reference"
        );
        assert!(
            !code.contains("pub struct FfiByteBuffer"),
            "FfiByteBuffer struct should not be generated (lives in witffi-types)"
        );
        assert!(code.contains("pub trait Eip681"), "missing trait Eip681");
        assert!(
            code.contains("fn parser_parse(input: &str) -> Result<FfiTransactionRequest, String>"),
            "missing or wrong trait method signature"
        );
        assert!(
            code.contains("macro_rules! witffi_register"),
            "missing witffi_register macro"
        );
        assert!(
            code.contains("zcash_eip681_parser_parse(input: witffi_types::FfiByteSlice)"),
            "missing parser_parse fn or wrong param type"
        );
        assert!(
            code.contains("<$impl_type>::parser_parse"),
            "missing concrete impl type call in macro"
        );
        assert!(
            code.contains("pub unsafe extern \"C\" fn zcash_eip681_free_byte_buffer"),
            "missing free_byte_buffer fn"
        );
        assert!(
            code.contains("witffi_types::free_ptr(ptr)"),
            "missing witffi_types::free_ptr call in domain free functions"
        );
    }

    #[test]
    fn test_generate_c_header_from_eip681() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let config = RustConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };

        let generator = RustGenerator::new(&resolve, world_id, config);
        let header = generator
            .generate_c_header()
            .expect("failed to generate C header");

        eprintln!("=== Generated C header ===\n{header}");

        assert!(header.contains("#pragma once"), "missing pragma once");
        assert!(header.contains("FfiByteBuffer"), "missing FfiByteBuffer");
        assert!(header.contains("FfiByteSlice"), "missing FfiByteSlice");
        assert!(
            header.contains("zcash_eip681_parser_parse(FfiByteSlice input)"),
            "missing parser_parse or wrong param type"
        );
    }

    #[test]
    fn test_generated_rust_compiles() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) = load_wit(&wit_path).expect("failed to load eip681.wit");

        let config = RustConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };

        let generator = RustGenerator::new(&resolve, world_id, config);
        let mut code = generator.generate().expect("failed to generate Rust code");

        // Append a mock implementation + macro invocation so we can verify
        // the full generated code compiles including the macro expansion.
        code.push_str(
            r#"
use std::ptr;

struct MockImpl;

impl Eip681 for MockImpl {
    fn parser_parse(input: &str) -> Result<FfiTransactionRequest, String> {
        let _ = input;
        Ok(FfiTransactionRequest {
            tag: FfiTransactionRequestTag::Unrecognised,
            native: ptr::null_mut(),
            erc20: ptr::null_mut(),
            unrecognised: Box::into_raw(Box::new(FfiTransactionRequestUnrecognisedPayload {
                value: witffi_types::FfiByteBuffer::empty(),
            })),
        })
    }
}

witffi_register!(MockImpl);
"#,
        );

        let tmp_dir = std::env::temp_dir().join("witffi-compile-test");
        std::fs::create_dir_all(&tmp_dir).expect("failed to create temp dir");

        let src_path = tmp_dir.join("ffi.rs");
        std::fs::write(&src_path, &code).expect("failed to write generated code");

        // Find the witffi_types rlib so rustc can resolve `witffi_types::` paths.
        // The test binary's deps directory contains the compiled dependency.
        let deps_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../target/debug/deps");
        let witffi_types_rlib = std::fs::read_dir(&deps_dir)
            .expect("failed to read deps dir")
            .filter_map(|e| e.ok())
            .find(|e| {
                let name = e.file_name();
                let name = name.to_string_lossy();
                name.starts_with("libwitffi_types-") && name.ends_with(".rlib")
            })
            .expect("could not find libwitffi_types-*.rlib in target/debug/deps")
            .path();

        let output = std::process::Command::new("rustc")
            .args(["--edition", "2024", "--crate-type", "lib", "-o"])
            .arg(tmp_dir.join("libffi.rlib"))
            .arg("--extern")
            .arg(format!("witffi_types={}", witffi_types_rlib.display()))
            .arg(&src_path)
            .output()
            .expect("failed to invoke rustc");

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            eprintln!("=== rustc failed ===\n{stderr}");
            eprintln!("=== generated code ===\n{code}");
            panic!("generated Rust code does not compile");
        }

        // Cleanup
        let _ = std::fs::remove_dir_all(&tmp_dir);
    }
}
