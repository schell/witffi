//! Swift bindings code generator.
//!
//! Walks the resolved WIT types and produces a single `.swift` file containing:
//! 1. Native Swift structs for WIT records
//! 2. Swift enums with associated values for WIT variants
//! 3. Swift enums for WIT enums
//! 4. Wrapper functions that call the C FFI layer and convert types
//! 5. Internal helpers for marshalling between Swift and C types
//!
//! The generated Swift code assumes a C module (configured via `c_prefix`) is
//! available via a `module.modulemap` that wraps `ffi.h` + `witffi_types.h`.

use std::collections::HashSet;
use std::fmt::Write;

use heck::ToPascalCase;
use snafu::prelude::*;
use wit_parser::{Resolve, Type, TypeDefKind, TypeId, WorldId};

use witffi_core::{ExportedFunction, exported_functions, names};

/// Errors that can occur during Swift code generation.
#[derive(Debug, Snafu)]
pub enum Error {
    /// A write to the output buffer failed.
    #[snafu(display("code generation write error"))]
    Write { source: std::fmt::Error },
}

/// Configuration for the Swift generator.
#[derive(Debug, Clone)]
pub struct SwiftConfig {
    /// Prefix for C function names (e.g. "zcash_eip681").
    ///
    /// Used to derive the C module import name (`C` + PascalCase of prefix)
    /// and to reference the correct C function symbols.
    pub c_prefix: String,

    /// Prefix for C type names (e.g. "Ffi").
    pub c_type_prefix: String,
}

impl Default for SwiftConfig {
    fn default() -> Self {
        Self {
            c_prefix: "witffi".to_string(),
            c_type_prefix: "Ffi".to_string(),
        }
    }
}

/// Generates Swift bindings from a resolved WIT world.
pub struct SwiftGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: SwiftConfig,
}

impl<'a> SwiftGenerator<'a> {
    /// Create a new Swift generator.
    ///
    /// # Arguments
    ///
    /// * `resolve` — The resolved WIT package
    /// * `world_id` — The world to generate bindings for
    /// * `config` — Generator configuration (C prefix, type prefix)
    pub fn new(resolve: &'a Resolve, world_id: WorldId, config: SwiftConfig) -> Self {
        Self {
            resolve,
            world_id,
            config,
        }
    }

    /// Generate all Swift bindings code as a single string.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    /// Generate a Clang `module.modulemap` that wraps the C headers.
    ///
    /// The module name is derived from `c_prefix` (e.g. `"zcash_eip681"` →
    /// `"CZcashEip681"`). The generated map references `ffi.h` and
    /// `witffi_types.h`, which must be placed alongside the modulemap.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate_module_map(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_module_map_inner(&mut out)
            .context(WriteSnafu)?;
        Ok(out)
    }

    fn generate_module_map_inner(&self, out: &mut String) -> std::fmt::Result {
        let module_name = self.c_module_name();
        writeln!(out, "module {module_name} {{")?;
        writeln!(out, "    header \"ffi.h\"")?;
        writeln!(out, "    header \"witffi_types.h\"")?;
        writeln!(out, "    export *")?;
        writeln!(out, "}}")?;
        Ok(())
    }

    fn generate_inner(&self, out: &mut String) -> std::fmt::Result {
        self.generate_header(out)?;
        writeln!(out)?;
        self.generate_error_type(out)?;
        writeln!(out)?;
        self.generate_helpers(out)?;
        writeln!(out)?;
        self.generate_types(out)?;
        writeln!(out)?;
        self.generate_api(out)?;

        Ok(())
    }

    // ---- C module name derivation ----

    /// Derive the C module import name from the `c_prefix`.
    ///
    /// E.g. `"zcash_eip681"` → `"CZcashEip681"`.
    fn c_module_name(&self) -> String {
        format!("C{}", self.config.c_prefix.to_pascal_case())
    }

    /// Get the C function prefix in snake_case form.
    fn c_func_prefix(&self) -> String {
        use heck::ToSnakeCase;
        self.config.c_prefix.to_snake_case()
    }

    // ---- Doc comment helper ----

    /// Write a Swift doc comment, handling multi-line content.
    fn write_doc_comment(out: &mut String, docs: &str, indent: &str) -> std::fmt::Result {
        for line in docs.trim_end().lines() {
            if line.is_empty() {
                writeln!(out, "{indent}///")?;
            } else {
                writeln!(out, "{indent}/// {line}")?;
            }
        }
        Ok(())
    }

    // ---- Header generation ----

    fn generate_header(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// Auto-generated by witffi. Do not edit.")?;
        writeln!(out)?;
        writeln!(out, "import {}", self.c_module_name())?;
        writeln!(out, "import Foundation")?;

        Ok(())
    }

    // ---- Error type ----

    fn generate_error_type(&self, out: &mut String) -> std::fmt::Result {
        let prefix = self.c_func_prefix();

        writeln!(out, "// MARK: - Error Type")?;
        writeln!(out)?;
        writeln!(out, "/// An error returned by the FFI layer.")?;
        writeln!(
            out,
            "public struct WitFFIError: Error, CustomStringConvertible {{"
        )?;
        writeln!(out, "    /// The error message from the FFI layer.")?;
        writeln!(out, "    public let message: String")?;
        writeln!(out)?;
        writeln!(out, "    public var description: String {{ message }}")?;
        writeln!(out)?;
        writeln!(
            out,
            "    /// Read the last error from the FFI thread-local storage."
        )?;
        writeln!(
            out,
            "    internal static func readLastError() -> WitFFIError {{"
        )?;
        writeln!(out, "        let len = {prefix}_last_error_length()")?;
        writeln!(out, "        guard len > 0 else {{")?;
        writeln!(
            out,
            "            return WitFFIError(message: \"unknown error\")"
        )?;
        writeln!(out, "        }}")?;
        writeln!(
            out,
            "        var buf = [CChar](repeating: 0, count: Int(len))"
        )?;
        writeln!(
            out,
            "        let copied = {prefix}_error_message_utf8(&buf, len)"
        )?;
        writeln!(out, "        if copied > 0 {{")?;
        writeln!(
            out,
            "            let msg = buf.withUnsafeBufferPointer {{ ptr in"
        )?;
        writeln!(
            out,
            "                String(decoding: UnsafeRawBufferPointer(ptr).prefix(Int(copied - 1)), as: UTF8.self)"
        )?;
        writeln!(out, "            }}")?;
        writeln!(out, "            return WitFFIError(message: msg)")?;
        writeln!(out, "        }} else {{")?;
        writeln!(
            out,
            "            return WitFFIError(message: \"unknown error\")"
        )?;
        writeln!(out, "        }}")?;
        writeln!(out, "    }}")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    // ---- Internal helpers ----

    fn generate_helpers(&self, out: &mut String) -> std::fmt::Result {
        let prefix = self.c_func_prefix();

        writeln!(out, "// MARK: - Internal Helpers")?;
        writeln!(out)?;

        // FfiByteBuffer → String
        writeln!(
            out,
            "/// Convert an `FfiByteBuffer` to a Swift `String`, freeing the buffer."
        )?;
        writeln!(
            out,
            "private func ffiByteBufferToString(_ buf: FfiByteBuffer) -> String {{"
        )?;
        writeln!(out, "    if buf.ptr == nil || buf.len == 0 {{")?;
        writeln!(out, "        if buf.ptr != nil {{")?;
        writeln!(out, "            let copy = buf")?;
        writeln!(out, "            {prefix}_free_byte_buffer(copy)")?;
        writeln!(out, "        }}")?;
        writeln!(out, "        return \"\"")?;
        writeln!(out, "    }}")?;
        writeln!(out, "    let data = Data(bytes: buf.ptr, count: buf.len)")?;
        writeln!(out, "    let copy = buf")?;
        writeln!(out, "    {prefix}_free_byte_buffer(copy)")?;
        writeln!(
            out,
            "    return String(data: data, encoding: .utf8) ?? \"\""
        )?;
        writeln!(out, "}}")?;
        writeln!(out)?;

        // FfiByteBuffer → Data
        writeln!(
            out,
            "/// Convert an `FfiByteBuffer` to a Swift `Data`, freeing the buffer."
        )?;
        writeln!(
            out,
            "private func ffiByteBufferToData(_ buf: FfiByteBuffer) -> Data {{"
        )?;
        writeln!(out, "    if buf.ptr == nil || buf.len == 0 {{")?;
        writeln!(out, "        if buf.ptr != nil {{")?;
        writeln!(out, "            let copy = buf")?;
        writeln!(out, "            {prefix}_free_byte_buffer(copy)")?;
        writeln!(out, "        }}")?;
        writeln!(out, "        return Data()")?;
        writeln!(out, "    }}")?;
        writeln!(out, "    let data = Data(bytes: buf.ptr, count: buf.len)")?;
        writeln!(out, "    let copy = buf")?;
        writeln!(out, "    {prefix}_free_byte_buffer(copy)")?;
        writeln!(out, "    return data")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    // ---- Helpers for collecting reachable types ----

    /// Collect all type IDs reachable from the world's exports,
    /// following type aliases and nested type references.
    /// Returns types in dependency order (dependencies before dependents).
    fn collect_reachable_types(&self) -> Vec<TypeId> {
        let mut visited = HashSet::new();
        let mut order = Vec::new();

        let world = &self.resolve.worlds[self.world_id];
        for (_key, item) in &world.exports {
            if let wit_parser::WorldItem::Interface { id, .. } = item {
                let iface = &self.resolve.interfaces[*id];
                for (_name, type_id) in &iface.types {
                    self.visit_type_id(*type_id, &mut visited, &mut order);
                }
                for (_fname, func) in &iface.functions {
                    for p in &func.params {
                        self.visit_type(&p.ty, &mut visited, &mut order);
                    }
                    if let Some(ty) = &func.result {
                        self.visit_type(ty, &mut visited, &mut order);
                    }
                }
            }
        }

        order
    }

    fn visit_type_id(
        &self,
        type_id: TypeId,
        visited: &mut HashSet<TypeId>,
        order: &mut Vec<TypeId>,
    ) {
        if !visited.insert(type_id) {
            return;
        }

        let typedef = &self.resolve.types[type_id];

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                for field in &record.fields {
                    self.visit_type(&field.ty, visited, order);
                }
            }
            TypeDefKind::Variant(variant) => {
                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        self.visit_type(ty, visited, order);
                    }
                }
            }
            TypeDefKind::List(ty) | TypeDefKind::Option(ty) => {
                self.visit_type(ty, visited, order);
            }
            TypeDefKind::Result(r) => {
                if let Some(ok) = &r.ok {
                    self.visit_type(ok, visited, order);
                }
                if let Some(err) = &r.err {
                    self.visit_type(err, visited, order);
                }
            }
            TypeDefKind::Tuple(tuple) => {
                for ty in &tuple.types {
                    self.visit_type(ty, visited, order);
                }
            }
            TypeDefKind::Type(ty) => {
                self.visit_type(ty, visited, order);
            }
            _ => {}
        }

        order.push(type_id);
    }

    fn visit_type(&self, ty: &Type, visited: &mut HashSet<TypeId>, order: &mut Vec<TypeId>) {
        if let Type::Id(id) = ty {
            self.visit_type_id(*id, visited, order);
        }
    }

    // ---- Helpers for understanding function result types ----

    /// Check if a function's return type is `result<T, E>` at the top level.
    fn decompose_result(&self, result: &Option<Type>) -> Option<(Option<Type>, Option<Type>)> {
        match result {
            Some(Type::Id(id)) => {
                let typedef = &self.resolve.types[*id];
                if let TypeDefKind::Result(r) = &typedef.kind {
                    Some((r.ok, r.err))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    // ---- Swift type mapping ----

    /// Map a WIT type to its idiomatic Swift representation.
    fn type_to_swift(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "Bool".to_string(),
            Type::U8 => "UInt8".to_string(),
            Type::U16 => "UInt16".to_string(),
            Type::U32 => "UInt32".to_string(),
            Type::U64 => "UInt64".to_string(),
            Type::S8 => "Int8".to_string(),
            Type::S16 => "Int16".to_string(),
            Type::S32 => "Int32".to_string(),
            Type::S64 => "Int64".to_string(),
            Type::F32 => "Float".to_string(),
            Type::F64 => "Double".to_string(),
            Type::Char => "Character".to_string(),
            Type::String => "String".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "Data".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("[{}]", self.type_to_swift(inner))
                    }
                    TypeDefKind::Option(inner) => {
                        format!("{}?", self.type_to_swift(inner))
                    }
                    TypeDefKind::Result(r) => {
                        // result<T, E> is handled via throws at the function level;
                        // if it appears as a field type, use a tuple representation.
                        let ok_ty =
                            r.ok.as_ref()
                                .map(|t| self.type_to_swift(t))
                                .unwrap_or_else(|| "Void".to_string());
                        let err_ty = r
                            .err
                            .as_ref()
                            .map(|t| self.type_to_swift(t))
                            .unwrap_or_else(|| "Void".to_string());
                        format!("Result<{ok_ty}, {err_ty}>")
                    }
                    TypeDefKind::Tuple(tuple) => {
                        let types: Vec<String> =
                            tuple.types.iter().map(|t| self.type_to_swift(t)).collect();
                        format!("({})", types.join(", "))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_swift(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        names::to_swift_type(name)
                    }
                }
            }
            Type::ErrorContext => "String".to_string(),
        }
    }

    /// Map a WIT type to its C FFI representation as seen from Swift.
    ///
    /// Swift imports the C types directly, so these are the C type names
    /// that appear in the generated bridging header.
    #[allow(dead_code)]
    fn type_to_c_swift(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "Bool".to_string(),
            Type::U8 => "UInt8".to_string(),
            Type::U16 => "UInt16".to_string(),
            Type::U32 => "UInt32".to_string(),
            Type::U64 => "UInt64".to_string(),
            Type::S8 => "Int8".to_string(),
            Type::S16 => "Int16".to_string(),
            Type::S32 => "Int32".to_string(),
            Type::S64 => "Int64".to_string(),
            Type::F32 => "Float".to_string(),
            Type::F64 => "Double".to_string(),
            Type::Char => "UInt32".to_string(),
            Type::String => "FfiByteBuffer".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(_) => "FfiByteBuffer".to_string(),
                    TypeDefKind::Option(inner) => {
                        format!("UnsafeMutablePointer<{}>?", self.type_to_c_swift(inner))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_c_swift(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        names::to_c_type(&self.config.c_type_prefix, name)
                    }
                }
            }
            Type::ErrorContext => "UInt32".to_string(),
        }
    }

    // ---- Swift type generation ----

    fn generate_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// MARK: - Types")?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let swift_name = names::to_swift_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "public struct {swift_name} {{")?;
                for field in &record.fields {
                    let field_name = names::to_swift_ident(&field.name);
                    let field_type = self.type_to_swift(&field.ty);
                    if let Some(docs) = &field.docs.contents {
                        Self::write_doc_comment(out, docs, "    ")?;
                    }
                    writeln!(out, "    public let {field_name}: {field_type}")?;
                }
                writeln!(out, "}}")?;
            }

            TypeDefKind::Variant(variant) => {
                let swift_name = names::to_swift_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "public enum {swift_name} {{")?;
                for case in &variant.cases {
                    let case_name = names::to_swift_ident(&case.name);
                    if let Some(docs) = &case.docs.contents {
                        Self::write_doc_comment(out, docs, "    ")?;
                    }
                    if let Some(ty) = &case.ty {
                        let payload_type = self.type_to_swift(ty);
                        writeln!(out, "    case {case_name}({payload_type})")?;
                    } else {
                        writeln!(out, "    case {case_name}")?;
                    }
                }
                writeln!(out, "}}")?;
            }

            TypeDefKind::Enum(e) => {
                let swift_name = names::to_swift_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "public enum {swift_name}: UInt32 {{")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let case_name = names::to_swift_ident(&case.name);
                    if let Some(docs) = &case.docs.contents {
                        Self::write_doc_comment(out, docs, "    ")?;
                    }
                    writeln!(out, "    case {case_name} = {i}")?;
                }
                writeln!(out, "}}")?;
            }

            TypeDefKind::Flags(flags) => {
                let swift_name = names::to_swift_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "public struct {swift_name}: OptionSet {{")?;
                writeln!(out, "    public let rawValue: UInt32")?;
                writeln!(out)?;
                writeln!(out, "    public init(rawValue: UInt32) {{")?;
                writeln!(out, "        self.rawValue = rawValue")?;
                writeln!(out, "    }}")?;
                writeln!(out)?;
                for (i, flag) in flags.flags.iter().enumerate() {
                    let flag_name = names::to_swift_ident(&flag.name);
                    if let Some(docs) = &flag.docs.contents {
                        Self::write_doc_comment(out, docs, "    ")?;
                    }
                    writeln!(
                        out,
                        "    public static let {flag_name} = {swift_name}(rawValue: 1 << {i})"
                    )?;
                }
                writeln!(out, "}}")?;
            }

            TypeDefKind::Type(inner) => {
                let swift_name = names::to_swift_type(wit_name);
                let inner_ty = self.type_to_swift(inner);
                // Skip self-referential aliases
                if swift_name != inner_ty {
                    writeln!(out)?;
                    writeln!(out, "public typealias {swift_name} = {inner_ty}")?;
                }
            }

            TypeDefKind::List(_)
            | TypeDefKind::Option(_)
            | TypeDefKind::Result(_)
            | TypeDefKind::Tuple(_) => {
                // Handled inline when they appear as field/param types
            }

            other => {
                writeln!(
                    out,
                    "// TODO: generate Swift type for {wit_name} (kind: {})",
                    other.as_str()
                )?;
            }
        }

        Ok(())
    }

    // ---- FFI-to-Swift conversion generation ----

    /// Generate a Swift expression that converts an FFI field value to a Swift type.
    ///
    /// `access` is the Swift expression to read the FFI value (e.g. `ffi.schemaPrefix`).
    fn convert_ffi_to_swift(&self, ty: &Type, access: &str) -> String {
        match ty {
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => access.to_string(),
            Type::Char => format!("Character(UnicodeScalar({access})!)"),
            Type::String => format!("ffiByteBufferToString({access})"),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("ffiByteBufferToData({access})")
                    }
                    TypeDefKind::List(_) => {
                        // General list conversion — not yet supported
                        format!("ffiByteBufferToData({access}) /* TODO: decode list elements */")
                    }
                    TypeDefKind::Option(inner) => {
                        let inner_convert = self.convert_ffi_option_inner(inner);
                        format!(
                            "({access}).map({{ ptr in {} }})",
                            inner_convert("ptr.pointee")
                        )
                    }
                    TypeDefKind::Type(aliased) => self.convert_ffi_to_swift(aliased, access),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        let swift_name = names::to_swift_type(name);
                        format!("convert{swift_name}({access})")
                    }
                }
            }
            Type::ErrorContext => format!("String({access})"),
        }
    }

    /// Return a closure expression string for converting an optional's inner value.
    ///
    /// Takes the inner type and returns a function `String -> String` that wraps
    /// an access expression with the appropriate conversion.
    fn convert_ffi_option_inner(&self, inner: &Type) -> Box<dyn Fn(&str) -> String + '_> {
        match inner {
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => Box::new(|access: &str| access.to_string()),
            Type::String => Box::new(|access: &str| format!("ffiByteBufferToString({access})")),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        Box::new(|access: &str| format!("ffiByteBufferToData({access})"))
                    }
                    TypeDefKind::Type(aliased) => self.convert_ffi_option_inner(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous").to_string();
                        Box::new(move |access: &str| {
                            let swift_name = names::to_swift_type(&name);
                            format!("convert{swift_name}({access})")
                        })
                    }
                }
            }
            _ => Box::new(|access: &str| access.to_string()),
        }
    }

    // ---- Conversion function generation ----

    /// Generate private conversion functions for each reachable record and variant.
    fn generate_conversion_functions(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// MARK: - FFI Conversion Functions")?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(record) => {
                    let swift_name = names::to_swift_type(wit_name);
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let free_func =
                        names::to_c_func(&self.config.c_prefix, &format!("free-{wit_name}"));

                    writeln!(out)?;
                    writeln!(
                        out,
                        "/// Convert a C `{c_name}` to a Swift `{swift_name}`, freeing the C memory."
                    )?;
                    writeln!(
                        out,
                        "private func convert{swift_name}(_ ffi: {c_name}) -> {swift_name} {{"
                    )?;

                    // Build field conversions
                    let mut field_args = Vec::new();
                    for field in &record.fields {
                        let swift_field = names::to_swift_ident(&field.name);
                        let c_field = names::to_rust_ident(&field.name);
                        let conversion =
                            self.convert_ffi_to_swift(&field.ty, &format!("ffi.{c_field}"));
                        field_args.push(format!("        {swift_field}: {conversion}"));
                    }

                    writeln!(out, "    return {swift_name}(")?;
                    writeln!(out, "{}", field_args.join(",\n"))?;
                    writeln!(out, "    )")?;
                    writeln!(out, "}}")?;

                    // Also generate a pointer variant that frees the pointer
                    writeln!(out)?;
                    writeln!(
                        out,
                        "/// Convert a C `{c_name}*` to a Swift `{swift_name}`, freeing the pointer."
                    )?;
                    writeln!(
                        out,
                        "private func convert{swift_name}Ptr(_ ptr: UnsafeMutablePointer<{c_name}>) -> {swift_name} {{"
                    )?;
                    writeln!(out, "    let value = convert{swift_name}(ptr.pointee)")?;
                    writeln!(out, "    {free_func}(ptr)")?;
                    writeln!(out, "    return value")?;
                    writeln!(out, "}}")?;
                }

                TypeDefKind::Variant(variant) => {
                    let swift_name = names::to_swift_type(wit_name);
                    let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);
                    let free_func =
                        names::to_c_func(&self.config.c_prefix, &format!("free-{wit_name}"));

                    writeln!(out)?;
                    writeln!(out, "/// Convert a C `{c_name}` to a Swift `{swift_name}`.")?;
                    writeln!(
                        out,
                        "private func convert{swift_name}(_ ffi: {c_name}) -> {swift_name} {{"
                    )?;
                    writeln!(out, "    switch ffi.tag {{")?;

                    for case in &variant.cases {
                        let c_tag_variant = names::to_c_enum_variant(&c_name, &case.name);
                        let swift_case = names::to_swift_ident(&case.name);

                        if let Some(ty) = &case.ty {
                            let c_field = names::to_rust_ident(&case.name);
                            let payload_conversion = self.convert_variant_payload(ty, &c_field);
                            writeln!(out, "    case {c_tag_variant}:")?;
                            writeln!(out, "        {payload_conversion}")?;
                            writeln!(out, "        return .{swift_case}(payload)")?;
                        } else {
                            writeln!(out, "    case {c_tag_variant}:")?;
                            writeln!(out, "        return .{swift_case}")?;
                        }
                    }

                    writeln!(out, "    default:")?;
                    writeln!(
                        out,
                        "        fatalError(\"Unknown {swift_name} tag: \\(ffi.tag)\")"
                    )?;
                    writeln!(out, "    }}")?;
                    writeln!(out, "}}")?;

                    // Pointer variant
                    writeln!(out)?;
                    writeln!(
                        out,
                        "/// Convert a C `{c_name}*` to a Swift `{swift_name}`, freeing the pointer."
                    )?;
                    writeln!(
                        out,
                        "private func convert{swift_name}Ptr(_ ptr: UnsafeMutablePointer<{c_name}>) -> {swift_name} {{"
                    )?;
                    writeln!(out, "    let value = convert{swift_name}(ptr.pointee)")?;
                    writeln!(out, "    {free_func}(ptr)")?;
                    writeln!(out, "    return value")?;
                    writeln!(out, "}}")?;
                }

                _ => {
                    // Other type kinds (enums, flags, aliases) don't need
                    // conversion functions — they map directly or inline.
                }
            }
        }

        Ok(())
    }

    /// Generate Swift code to extract a variant case payload from the FFI struct.
    fn convert_variant_payload(&self, ty: &Type, c_field: &str) -> String {
        match ty {
            Type::String => {
                format!("let payload = ffiByteBufferToString(ffi.{c_field}!.pointee.value)")
            }
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("let payload = ffiByteBufferToData(ffi.{c_field}!.pointee.value)")
                    }
                    TypeDefKind::Type(aliased) => self.convert_variant_payload(aliased, c_field),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        let swift_name = names::to_swift_type(name);
                        format!("let payload = convert{swift_name}(ffi.{c_field}!.pointee.value)")
                    }
                }
            }
            _ => {
                // Primitive payload
                format!("let payload = ffi.{c_field}!.pointee.value")
            }
        }
    }

    // ---- Public API generation ----

    fn generate_api(&self, out: &mut String) -> std::fmt::Result {
        // Generate conversion functions first (they are private, used by the API)
        self.generate_conversion_functions(out)?;
        writeln!(out)?;

        let world = &self.resolve.worlds[self.world_id];
        let namespace = names::to_swift_type(&world.name);

        writeln!(out, "// MARK: - Public API")?;
        writeln!(out)?;
        writeln!(out, "/// {namespace} FFI bindings.")?;
        writeln!(out, "public enum {namespace} {{")?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            self.generate_api_function(out, ef)?;
        }

        writeln!(out, "}}")?;

        Ok(())
    }

    fn generate_api_function(&self, out: &mut String, ef: &ExportedFunction) -> std::fmt::Result {
        let c_func_name = if ef.interface_name.is_empty() {
            names::to_c_func(&self.config.c_prefix, &ef.function_name)
        } else {
            names::to_c_func(
                &self.config.c_prefix,
                &format!("{}_{}", ef.interface_name, ef.function_name),
            )
        };

        // Build the Swift method name from interface + function
        let swift_method = if ef.interface_name.is_empty() {
            names::to_swift_ident(&ef.function_name)
        } else {
            names::to_swift_ident(&format!("{}_{}", ef.interface_name, ef.function_name))
        };

        let result_decomposed = self.decompose_result(&ef.function.result);

        // Build Swift parameters
        let swift_params: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                let name = names::to_swift_ident(&p.name);
                let ty = self.type_to_swift(&p.ty);
                format!("_ {name}: {ty}")
            })
            .collect();

        // Build return type
        let (swift_return, is_throwing) = if let Some((ok_ty, _err_ty)) = &result_decomposed {
            let ret = ok_ty
                .as_ref()
                .map(|t| self.type_to_swift(t))
                .unwrap_or_else(|| "Void".to_string());
            (ret, true)
        } else {
            let ret = ef
                .function
                .result
                .as_ref()
                .map(|t| self.type_to_swift(t))
                .unwrap_or_else(|| "Void".to_string());
            (ret, false)
        };

        // Emit function signature
        writeln!(out)?;
        if let Some(docs) = &ef.function.docs.contents {
            Self::write_doc_comment(out, docs, "    ")?;
        }
        let throws_clause = if is_throwing { " throws" } else { "" };
        let return_clause = if swift_return == "Void" {
            String::new()
        } else {
            format!(" -> {swift_return}")
        };
        writeln!(
            out,
            "    public static func {swift_method}({params}){throws_clause}{return_clause} {{",
            params = swift_params.join(", ")
        )?;

        // Generate the function body
        self.generate_api_function_body(out, ef, &c_func_name, &result_decomposed)?;

        writeln!(out, "    }}")?;

        Ok(())
    }

    fn generate_api_function_body(
        &self,
        out: &mut String,
        ef: &ExportedFunction,
        c_func_name: &str,
        result_decomposed: &Option<(Option<Type>, Option<Type>)>,
    ) -> std::fmt::Result {
        // For each string/data parameter, we need to marshal into FfiByteSlice.
        // We use nested closures to keep pointers valid.
        let params = &ef.function.params;
        let has_string_params = params.iter().any(|p| self.param_needs_marshaling(&p.ty));

        if has_string_params {
            // Open nested withUTF8 closures for string parameters
            let mut nesting = 0;
            for p in params {
                if self.param_needs_marshaling(&p.ty) {
                    let name = names::to_swift_ident(&p.name);
                    let indent = "        ".to_string() + &"    ".repeat(nesting);
                    writeln!(
                        out,
                        "{indent}return try {name}.utf8CString.withUnsafeBufferPointer {{ {name}Buf in",
                    )?;
                    writeln!(
                        out,
                        "{indent}    let {name}Slice = FfiByteSlice(ptr: UnsafeRawPointer({name}Buf.baseAddress!).assumingMemoryBound(to: UInt8.self), len: {name}Buf.count - 1)",
                    )?;
                    nesting += 1;
                }
            }

            // Build C function call arguments
            let c_args = self.build_c_call_args(params);
            let inner_indent = "        ".to_string() + &"    ".repeat(nesting);

            // Call the C function and handle result
            self.generate_c_call_and_result(
                out,
                c_func_name,
                &c_args,
                &ef.function.result,
                result_decomposed,
                &inner_indent,
            )?;

            // Close nested closures
            for i in (0..nesting).rev() {
                let indent = "        ".to_string() + &"    ".repeat(i);
                writeln!(out, "{indent}}}")?;
            }
        } else {
            // No string marshaling needed, call directly
            let c_args = self.build_c_call_args(params);
            self.generate_c_call_and_result(
                out,
                c_func_name,
                &c_args,
                &ef.function.result,
                result_decomposed,
                "        ",
            )?;
        }

        Ok(())
    }

    /// Check if a parameter type needs marshaling (String → FfiByteSlice).
    fn param_needs_marshaling(&self, ty: &Type) -> bool {
        match ty {
            Type::String => true,
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => true,
                    TypeDefKind::Type(aliased) => self.param_needs_marshaling(aliased),
                    _ => false,
                }
            }
            _ => false,
        }
    }

    /// Build the C function call argument list.
    fn build_c_call_args(&self, params: &[wit_parser::Param]) -> String {
        params
            .iter()
            .map(|p| {
                let name = names::to_swift_ident(&p.name);
                if self.param_needs_marshaling(&p.ty) {
                    format!("{name}Slice")
                } else {
                    name
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate the C function call and result handling.
    fn generate_c_call_and_result(
        &self,
        out: &mut String,
        c_func_name: &str,
        c_args: &str,
        func_result: &Option<Type>,
        result_decomposed: &Option<(Option<Type>, Option<Type>)>,
        indent: &str,
    ) -> std::fmt::Result {
        if let Some((ok_ty, _err_ty)) = result_decomposed {
            // result<T, E> → nullable pointer or bool
            if ok_ty.is_some() {
                // Returns *mut T (nullable pointer): null = error
                writeln!(out, "{indent}let resultPtr = {c_func_name}({c_args})")?;
                writeln!(out, "{indent}guard let resultPtr = resultPtr else {{")?;
                writeln!(out, "{indent}    throw WitFFIError.readLastError()")?;
                writeln!(out, "{indent}}}")?;

                // Convert the result pointer to Swift
                let ok_type = ok_ty.as_ref().unwrap();
                let conversion = self.convert_result_ptr(ok_type);
                writeln!(out, "{indent}return {conversion}")?;
            } else {
                // Returns bool: false = error
                writeln!(out, "{indent}let success = {c_func_name}({c_args})")?;
                writeln!(out, "{indent}if !success {{")?;
                writeln!(out, "{indent}    throw WitFFIError.readLastError()")?;
                writeln!(out, "{indent}}}")?;
            }
        } else if let Some(ret_ty) = func_result {
            // Non-result return type — direct conversion
            writeln!(out, "{indent}let result = {c_func_name}({c_args})")?;
            let conversion = self.convert_ffi_to_swift(ret_ty, "result");
            writeln!(out, "{indent}return {conversion}")?;
        } else {
            // Void return
            writeln!(out, "{indent}{c_func_name}({c_args})")?;
        }

        Ok(())
    }

    /// Generate Swift code to convert a result pointer to a Swift value.
    fn convert_result_ptr(&self, ty: &Type) -> String {
        match ty {
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        let swift_name = names::to_swift_type(name);
                        format!("convert{swift_name}Ptr(resultPtr)")
                    }
                    TypeDefKind::Type(aliased) => self.convert_result_ptr(aliased),
                    _ => "resultPtr.pointee".to_string(),
                }
            }
            Type::String => "ffiByteBufferToString(resultPtr.pointee)".to_string(),
            _ => "resultPtr.pointee".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::path::Path;

    use super::*;

    fn load_eip681() -> (Resolve, WorldId) {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        witffi_core::load_wit(&wit_path).expect("failed to load eip681.wit")
    }

    #[test]
    fn test_generate_swift_from_eip681() {
        let (resolve, world_id) = load_eip681();
        let config = SwiftConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };
        let generator = SwiftGenerator::new(&resolve, world_id, config);
        let swift = generator.generate().expect("generation failed");

        eprintln!("--- Generated Swift ---\n{swift}\n--- End ---");

        // Check header
        assert!(
            swift.contains("import CZcashEip681"),
            "should import C module"
        );
        assert!(
            swift.contains("import Foundation"),
            "should import Foundation"
        );

        // Check error type
        assert!(
            swift.contains("public struct WitFFIError: Error"),
            "should have error type"
        );
        assert!(
            swift.contains("zcash_eip681_last_error_length"),
            "should reference last_error_length"
        );

        // Check types
        assert!(
            swift.contains("public struct NativeRequest {"),
            "should have NativeRequest struct"
        );
        assert!(
            swift.contains("public let schemaPrefix: String"),
            "should have schemaPrefix field"
        );
        assert!(
            swift.contains("public let chainId: UInt64?"),
            "should have optional chainId"
        );
        assert!(
            swift.contains("public let valueAtomic: Data?"),
            "should have optional Data for u256"
        );

        assert!(
            swift.contains("public struct Erc20Request {"),
            "should have Erc20Request struct"
        );
        assert!(
            swift.contains("public let valueAtomic: Data"),
            "Erc20Request should have non-optional Data"
        );

        assert!(
            swift.contains("public enum TransactionRequest {"),
            "should have TransactionRequest enum"
        );
        assert!(
            swift.contains("case native(NativeRequest)"),
            "should have native case"
        );
        assert!(
            swift.contains("case erc20(Erc20Request)"),
            "should have erc20 case"
        );
        assert!(
            swift.contains("case unrecognised(String)"),
            "should have unrecognised case"
        );

        // Check API
        assert!(
            swift.contains("public enum Eip681 {"),
            "should have Eip681 namespace"
        );
        assert!(
            swift.contains("public static func parserParse"),
            "should have parserParse function"
        );
        assert!(swift.contains("throws"), "should be a throwing function");

        // Check conversion functions
        assert!(
            swift.contains("private func convertNativeRequest"),
            "should have conversion for NativeRequest"
        );
        assert!(
            swift.contains("private func convertTransactionRequest"),
            "should have conversion for TransactionRequest"
        );

        // Check helpers
        assert!(
            swift.contains("private func ffiByteBufferToString"),
            "should have buffer-to-string helper"
        );
        assert!(
            swift.contains("private func ffiByteBufferToData"),
            "should have buffer-to-data helper"
        );
    }

    #[test]
    fn test_swift_type_mapping() {
        let (resolve, world_id) = load_eip681();
        let config = SwiftConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };
        let generator = SwiftGenerator::new(&resolve, world_id, config);

        assert_eq!(generator.type_to_swift(&Type::Bool), "Bool");
        assert_eq!(generator.type_to_swift(&Type::U8), "UInt8");
        assert_eq!(generator.type_to_swift(&Type::U16), "UInt16");
        assert_eq!(generator.type_to_swift(&Type::U32), "UInt32");
        assert_eq!(generator.type_to_swift(&Type::U64), "UInt64");
        assert_eq!(generator.type_to_swift(&Type::S8), "Int8");
        assert_eq!(generator.type_to_swift(&Type::S16), "Int16");
        assert_eq!(generator.type_to_swift(&Type::S32), "Int32");
        assert_eq!(generator.type_to_swift(&Type::S64), "Int64");
        assert_eq!(generator.type_to_swift(&Type::F32), "Float");
        assert_eq!(generator.type_to_swift(&Type::F64), "Double");
        assert_eq!(generator.type_to_swift(&Type::Char), "Character");
        assert_eq!(generator.type_to_swift(&Type::String), "String");
    }

    #[test]
    fn test_c_module_name_derivation() {
        let (resolve, world_id) = load_eip681();

        let config = SwiftConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };
        let generator = SwiftGenerator::new(&resolve, world_id, config);
        assert_eq!(generator.c_module_name(), "CZcashEip681");

        let config2 = SwiftConfig {
            c_prefix: "my_cool_lib".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };
        let generator2 = SwiftGenerator::new(&resolve, world_id, config2);
        assert_eq!(generator2.c_module_name(), "CMyCoolLib");
    }

    #[test]
    fn test_generate_module_map() {
        let (resolve, world_id) = load_eip681();

        let config = SwiftConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
        };
        let generator = SwiftGenerator::new(&resolve, world_id, config);
        let module_map = generator.generate_module_map().unwrap();

        assert!(
            module_map.contains("module CZcashEip681"),
            "module map should use the derived C module name"
        );
        assert!(
            module_map.contains("header \"ffi.h\""),
            "module map should reference ffi.h"
        );
        assert!(
            module_map.contains("header \"witffi_types.h\""),
            "module map should reference witffi_types.h"
        );
        assert!(
            module_map.contains("export *"),
            "module map should export all symbols"
        );
    }
}
