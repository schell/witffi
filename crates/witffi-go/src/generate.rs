//! Go bindings code generator.
//!
//! Walks the resolved WIT types and produces a single `.go` file containing:
//! 1. CGo preamble with LDFLAGS and `#include` directives
//! 2. Helper functions for `FfiByteBuffer`/`FfiByteSlice` marshalling
//! 3. Go structs for WIT records
//! 4. Go interfaces + concrete types for WIT variants
//! 5. Go typed constants for WIT enums and flags
//! 6. Conversion functions (C struct -> Go type)
//! 7. Public API functions that call the C-ABI layer

use std::collections::HashSet;
use std::fmt::Write;

use heck::ToSnakeCase;
use snafu::prelude::*;
use wit_parser::{Resolve, Type, TypeDefKind, TypeId, WorldId};

use witffi_core::{ExportedFunction, exported_functions, names};

/// Errors that can occur during Go code generation.
#[derive(Debug, Snafu)]
pub enum Error {
    /// A write to the output buffer failed.
    #[snafu(display("code generation write error"))]
    Write { source: std::fmt::Error },
}

/// Configuration for the Go generator.
#[derive(Debug, Clone)]
pub struct GoConfig {
    /// Prefix for C function names (e.g. "zcash_eip681").
    pub c_prefix: String,

    /// Prefix for C type names (e.g. "Ffi").
    pub c_type_prefix: String,

    /// Override the Go package name. If `None`, derived from the WIT world name.
    pub go_package: Option<String>,

    /// Library name for CGo LDFLAGS (e.g. "eip681_ffi").
    pub lib_name: String,
}

impl Default for GoConfig {
    fn default() -> Self {
        Self {
            c_prefix: "witffi".to_string(),
            c_type_prefix: "Ffi".to_string(),
            go_package: None,
            lib_name: "witffi".to_string(),
        }
    }
}

/// Generates Go bindings from a resolved WIT world.
pub struct GoGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: GoConfig,
}

impl<'a> GoGenerator<'a> {
    /// Create a new Go generator.
    ///
    /// # Arguments
    ///
    /// * `resolve` — The resolved WIT package
    /// * `world_id` — The world to generate bindings for
    /// * `config` — Generator configuration
    pub fn new(resolve: &'a Resolve, world_id: WorldId, config: GoConfig) -> Self {
        Self {
            resolve,
            world_id,
            config,
        }
    }

    /// Generate all Go bindings code as a single string.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to the output buffer fails.
    pub fn generate(&self) -> Result<String, Error> {
        let mut out = String::new();
        self.generate_inner(&mut out).context(WriteSnafu)?;
        Ok(out)
    }

    fn generate_inner(&self, out: &mut String) -> std::fmt::Result {
        self.generate_header(out)?;
        self.generate_cgo_preamble(out)?;
        self.generate_imports(out)?;
        writeln!(out)?;
        self.generate_helpers(out)?;
        writeln!(out)?;
        self.generate_types(out)?;
        writeln!(out)?;
        self.generate_conversion_functions(out)?;
        writeln!(out)?;
        self.generate_api(out)?;

        Ok(())
    }

    // ---- Package name derivation ----

    /// Get the Go package name, either from config or derived from the world name.
    fn package_name(&self) -> String {
        if let Some(ref pkg) = self.config.go_package {
            pkg.clone()
        } else {
            let world = &self.resolve.worlds[self.world_id];
            world.name.clone()
        }
    }

    /// Get the C function prefix in snake_case form.
    fn c_func_prefix(&self) -> String {
        self.config.c_prefix.to_snake_case()
    }

    // ---- Doc comment helper ----

    /// Write a Go doc comment, handling multi-line content.
    fn write_doc_comment(out: &mut String, docs: &str, indent: &str) -> std::fmt::Result {
        for line in docs.trim_end().lines() {
            if line.is_empty() {
                writeln!(out, "{indent}//")?;
            } else {
                writeln!(out, "{indent}// {line}")?;
            }
        }
        Ok(())
    }

    // ---- Header generation ----

    fn generate_header(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// Code generated by witffi. DO NOT EDIT.")?;
        writeln!(out)?;
        writeln!(out, "package {}", self.package_name())?;

        Ok(())
    }

    // ---- CGo preamble ----

    fn generate_cgo_preamble(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out)?;
        writeln!(out, "/*")?;
        writeln!(out, "#cgo LDFLAGS: -l{}", self.config.lib_name)?;
        writeln!(out, "#include \"witffi_types.h\"")?;
        writeln!(out, "#include \"ffi.h\"")?;
        writeln!(out, "#include <stdlib.h>")?;
        // import "C" MUST immediately follow closing */ (CGo requirement)
        writeln!(out, "*/")?;
        writeln!(out, "import \"C\"")?;

        Ok(())
    }

    // ---- Go imports ----

    fn generate_imports(&self, out: &mut String) -> std::fmt::Result {
        let funcs = exported_functions(self.resolve, self.world_id);
        let has_result_funcs = funcs
            .iter()
            .any(|ef| self.decompose_result(&ef.function.result).is_some());
        let has_variants = self
            .collect_reachable_types()
            .iter()
            .any(|id| matches!(self.resolve.types[*id].kind, TypeDefKind::Variant(_)));
        let needs_fmt = has_result_funcs || has_variants;

        writeln!(out)?;
        writeln!(out, "import (")?;
        if needs_fmt {
            writeln!(out, "\t\"fmt\"")?;
        }
        writeln!(out, "\t\"unsafe\"")?;
        writeln!(out, ")")?;

        Ok(())
    }

    // ---- Helpers ----

    fn generate_helpers(&self, out: &mut String) -> std::fmt::Result {
        let prefix = self.c_func_prefix();

        writeln!(out, "// ---- Helpers ----")?;
        writeln!(out)?;

        // ffiByteBufferToString
        writeln!(
            out,
            "func ffiByteBufferToString(buf C.FfiByteBuffer) string {{"
        )?;
        writeln!(out, "\tif buf.ptr == nil || buf.len == 0 {{")?;
        writeln!(out, "\t\tC.{prefix}_free_byte_buffer(buf)")?;
        writeln!(out, "\t\treturn \"\"")?;
        writeln!(out, "\t}}")?;
        writeln!(
            out,
            "\ts := C.GoStringN((*C.char)(unsafe.Pointer(buf.ptr)), C.int(buf.len))"
        )?;
        writeln!(out, "\tC.{prefix}_free_byte_buffer(buf)")?;
        writeln!(out, "\treturn s")?;
        writeln!(out, "}}")?;
        writeln!(out)?;

        // ffiByteBufferToBytes
        writeln!(
            out,
            "func ffiByteBufferToBytes(buf C.FfiByteBuffer) []byte {{"
        )?;
        writeln!(out, "\tif buf.ptr == nil || buf.len == 0 {{")?;
        writeln!(out, "\t\tC.{prefix}_free_byte_buffer(buf)")?;
        writeln!(out, "\t\treturn nil")?;
        writeln!(out, "\t}}")?;
        writeln!(
            out,
            "\tb := C.GoBytes(unsafe.Pointer(buf.ptr), C.int(buf.len))"
        )?;
        writeln!(out, "\tC.{prefix}_free_byte_buffer(buf)")?;
        writeln!(out, "\treturn b")?;
        writeln!(out, "}}")?;
        writeln!(out)?;

        // readLastError
        writeln!(out, "func readLastError() string {{")?;
        writeln!(out, "\tlength := C.{prefix}_last_error_length()")?;
        writeln!(out, "\tif length <= 0 {{")?;
        writeln!(out, "\t\treturn \"unknown error\"")?;
        writeln!(out, "\t}}")?;
        writeln!(out, "\tbuf := make([]byte, length)")?;
        writeln!(
            out,
            "\tC.{prefix}_error_message_utf8((*C.char)(unsafe.Pointer(&buf[0])), length)"
        )?;
        writeln!(out, "\treturn string(buf[:length-1])")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    // ---- Reachable types ----

    /// Collect all type IDs reachable from the world's exports,
    /// following type aliases and nested type references.
    /// Returns types in dependency order (dependencies before dependents).
    fn collect_reachable_types(&self) -> Vec<TypeId> {
        let mut visited = HashSet::new();
        let mut order = Vec::new();

        let world = &self.resolve.worlds[self.world_id];
        for (_key, item) in &world.exports {
            if let wit_parser::WorldItem::Interface { id, .. } = item {
                let iface = &self.resolve.interfaces[*id];
                for (_name, type_id) in &iface.types {
                    self.visit_type_id(*type_id, &mut visited, &mut order);
                }
                for (_fname, func) in &iface.functions {
                    for p in &func.params {
                        self.visit_type(&p.ty, &mut visited, &mut order);
                    }
                    if let Some(ty) = &func.result {
                        self.visit_type(ty, &mut visited, &mut order);
                    }
                }
            }
        }

        order
    }

    fn visit_type_id(
        &self,
        type_id: TypeId,
        visited: &mut HashSet<TypeId>,
        order: &mut Vec<TypeId>,
    ) {
        if !visited.insert(type_id) {
            return;
        }

        let typedef = &self.resolve.types[type_id];

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                for field in &record.fields {
                    self.visit_type(&field.ty, visited, order);
                }
            }
            TypeDefKind::Variant(variant) => {
                for case in &variant.cases {
                    if let Some(ty) = &case.ty {
                        self.visit_type(ty, visited, order);
                    }
                }
            }
            TypeDefKind::List(ty) | TypeDefKind::Option(ty) => {
                self.visit_type(ty, visited, order);
            }
            TypeDefKind::Result(r) => {
                if let Some(ok) = &r.ok {
                    self.visit_type(ok, visited, order);
                }
                if let Some(err) = &r.err {
                    self.visit_type(err, visited, order);
                }
            }
            TypeDefKind::Tuple(tuple) => {
                for ty in &tuple.types {
                    self.visit_type(ty, visited, order);
                }
            }
            TypeDefKind::Type(ty) => {
                self.visit_type(ty, visited, order);
            }
            _ => {}
        }

        order.push(type_id);
    }

    fn visit_type(&self, ty: &Type, visited: &mut HashSet<TypeId>, order: &mut Vec<TypeId>) {
        if let Type::Id(id) = ty {
            self.visit_type_id(*id, visited, order);
        }
    }

    // ---- Result decomposition ----

    /// Check if a function's return type is `result<T, E>` at the top level.
    fn decompose_result(&self, result: &Option<Type>) -> Option<(Option<Type>, Option<Type>)> {
        match result {
            Some(Type::Id(id)) => {
                let typedef = &self.resolve.types[*id];
                if let TypeDefKind::Result(r) = &typedef.kind {
                    Some((r.ok, r.err))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    // ---- Go type mapping ----

    /// Map a WIT type to its idiomatic Go representation.
    fn type_to_go(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "uint8".to_string(),
            Type::U16 => "uint16".to_string(),
            Type::U32 => "uint32".to_string(),
            Type::U64 => "uint64".to_string(),
            Type::S8 => "int8".to_string(),
            Type::S16 => "int16".to_string(),
            Type::S32 => "int32".to_string(),
            Type::S64 => "int64".to_string(),
            Type::F32 => "float32".to_string(),
            Type::F64 => "float64".to_string(),
            Type::Char => "rune".to_string(),
            Type::String => "string".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => "[]byte".to_string(),
                    TypeDefKind::List(inner) => {
                        format!("[]{}", self.type_to_go(inner))
                    }
                    TypeDefKind::Option(inner) => {
                        format!("*{}", self.type_to_go(inner))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_go(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        names::to_go_type(name)
                    }
                }
            }
            Type::ErrorContext => "string".to_string(),
        }
    }

    /// Map a WIT type to its CGo C type representation.
    fn type_to_cgo(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "C.bool".to_string(),
            Type::U8 => "C.uint8_t".to_string(),
            Type::U16 => "C.uint16_t".to_string(),
            Type::U32 => "C.uint32_t".to_string(),
            Type::U64 => "C.uint64_t".to_string(),
            Type::S8 => "C.int8_t".to_string(),
            Type::S16 => "C.int16_t".to_string(),
            Type::S32 => "C.int32_t".to_string(),
            Type::S64 => "C.int64_t".to_string(),
            Type::F32 => "C.float".to_string(),
            Type::F64 => "C.double".to_string(),
            Type::Char => "C.uint32_t".to_string(),
            Type::String => "C.FfiByteBuffer".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(_) => "C.FfiByteBuffer".to_string(),
                    TypeDefKind::Option(inner) => {
                        format!("*{}", self.type_to_cgo(inner))
                    }
                    TypeDefKind::Type(aliased) => self.type_to_cgo(aliased),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        format!("C.{}", names::to_c_type(&self.config.c_type_prefix, name))
                    }
                }
            }
            Type::ErrorContext => "C.uint32_t".to_string(),
        }
    }

    // ---- Type generation ----

    fn generate_types(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- Types ----")?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            self.generate_type_def(out, *type_id)?;
        }

        Ok(())
    }

    fn generate_type_def(&self, out: &mut String, type_id: TypeId) -> std::fmt::Result {
        let typedef = &self.resolve.types[type_id];
        let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

        match &typedef.kind {
            TypeDefKind::Record(record) => {
                let go_name = names::to_go_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "type {go_name} struct {{")?;
                for field in &record.fields {
                    let field_name = names::to_go_field(&field.name);
                    let field_type = self.type_to_go(&field.ty);
                    if let Some(docs) = &field.docs.contents {
                        Self::write_doc_comment(out, docs, "\t")?;
                    }
                    writeln!(out, "\t{field_name} {field_type}")?;
                }
                writeln!(out, "}}")?;
            }

            TypeDefKind::Variant(variant) => {
                let go_name = names::to_go_type(wit_name);
                let marker_name = names::to_go_ident(wit_name);
                let marker_iface = format!("{marker_name}Variant");
                let marker_method = format!("is{go_name}");

                writeln!(out)?;
                // Unexported marker interface
                writeln!(out, "type {marker_iface} interface {{")?;
                writeln!(out, "\t{marker_method}()")?;
                writeln!(out, "}}")?;
                writeln!(out)?;

                // Public type alias
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "type {go_name} = {marker_iface}")?;

                // Concrete types for each variant case
                for case in &variant.cases {
                    let case_name = format!("{}{}", go_name, names::to_go_type(&case.name));
                    writeln!(out)?;
                    if let Some(docs) = &case.docs.contents {
                        Self::write_doc_comment(out, docs, "")?;
                    }
                    if let Some(ty) = &case.ty {
                        let payload_type = self.type_to_go(ty);
                        writeln!(out, "type {case_name} struct {{ Value {payload_type} }}")?;
                    } else {
                        writeln!(out, "type {case_name} struct{{}}")?;
                    }
                    writeln!(out, "func ({case_name}) {marker_method}() {{}}")?;
                }
            }

            TypeDefKind::Enum(e) => {
                let go_name = names::to_go_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "type {go_name} uint32")?;
                writeln!(out)?;
                writeln!(out, "const (")?;
                for (i, case) in e.cases.iter().enumerate() {
                    let variant_name = format!("{}{}", go_name, names::to_go_type(&case.name));
                    if let Some(docs) = &case.docs.contents {
                        Self::write_doc_comment(out, docs, "\t")?;
                    }
                    if i == 0 {
                        writeln!(out, "\t{variant_name} {go_name} = iota")?;
                    } else {
                        writeln!(out, "\t{variant_name}")?;
                    }
                }
                writeln!(out, ")")?;
            }

            TypeDefKind::Flags(flags) => {
                let go_name = names::to_go_type(wit_name);
                writeln!(out)?;
                if let Some(docs) = &typedef.docs.contents {
                    Self::write_doc_comment(out, docs, "")?;
                }
                writeln!(out, "type {go_name} uint32")?;
                writeln!(out)?;
                writeln!(out, "const (")?;
                for (i, flag) in flags.flags.iter().enumerate() {
                    let flag_name = format!("{}{}", go_name, names::to_go_type(&flag.name));
                    if let Some(docs) = &flag.docs.contents {
                        Self::write_doc_comment(out, docs, "\t")?;
                    }
                    if i == 0 {
                        writeln!(out, "\t{flag_name} {go_name} = 1 << iota")?;
                    } else {
                        writeln!(out, "\t{flag_name}")?;
                    }
                }
                writeln!(out, ")")?;
            }

            TypeDefKind::Type(inner) => {
                let go_name = names::to_go_type(wit_name);
                let inner_ty = self.type_to_go(inner);
                // Skip self-referential aliases
                if go_name != inner_ty {
                    writeln!(out)?;
                    writeln!(out, "type {go_name} = {inner_ty}")?;
                }
            }

            TypeDefKind::List(_)
            | TypeDefKind::Option(_)
            | TypeDefKind::Result(_)
            | TypeDefKind::Tuple(_) => {
                // Handled inline when they appear as field/param types
            }

            other => {
                writeln!(
                    out,
                    "// TODO: generate Go type for {wit_name} (kind: {})",
                    other.as_str()
                )?;
            }
        }

        Ok(())
    }

    // ---- Conversion functions ----

    fn generate_conversion_functions(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- Conversion Functions ----")?;

        let reachable = self.collect_reachable_types();
        for type_id in &reachable {
            let typedef = &self.resolve.types[*type_id];
            let wit_name = typedef.name.as_deref().unwrap_or("anonymous");

            match &typedef.kind {
                TypeDefKind::Record(record) => {
                    self.generate_record_conversion(out, wit_name, record)?;
                }
                TypeDefKind::Variant(variant) => {
                    self.generate_variant_conversion(out, wit_name, variant)?;
                }
                _ => {
                    // Other type kinds don't need conversion functions
                }
            }
        }

        Ok(())
    }

    fn generate_record_conversion(
        &self,
        out: &mut String,
        wit_name: &str,
        record: &wit_parser::Record,
    ) -> std::fmt::Result {
        let go_name = names::to_go_type(wit_name);
        let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);

        writeln!(out)?;
        writeln!(out, "func convert{go_name}(ffi C.{c_name}) {go_name} {{")?;

        // Separate fields into required (set in struct literal) and optional
        // (set after construction)
        let mut required_fields = Vec::new();
        let mut optional_fields = Vec::new();

        for field in &record.fields {
            if self.is_option_type(&field.ty) {
                optional_fields.push(field);
            } else {
                required_fields.push(field);
            }
        }

        // Build the struct literal with required fields
        writeln!(out, "\tresult := {go_name}{{")?;
        for field in &required_fields {
            let go_field = names::to_go_field(&field.name);
            let c_field = names::to_rust_ident(&field.name);
            let conversion = self.convert_ffi_to_go(&field.ty, &format!("ffi.{c_field}"));
            writeln!(out, "\t\t{go_field}: {conversion},")?;
        }
        writeln!(out, "\t}}")?;

        // Handle optional fields
        for field in &optional_fields {
            let go_field = names::to_go_field(&field.name);
            let c_field = names::to_rust_ident(&field.name);
            self.generate_optional_field_conversion(out, &go_field, &c_field, &field.ty)?;
        }

        writeln!(out, "\treturn result")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    fn generate_variant_conversion(
        &self,
        out: &mut String,
        wit_name: &str,
        variant: &wit_parser::Variant,
    ) -> std::fmt::Result {
        let go_name = names::to_go_type(wit_name);
        let c_name = names::to_c_type(&self.config.c_type_prefix, wit_name);

        writeln!(out)?;
        writeln!(out, "func convert{go_name}(ffi C.{c_name}) {go_name} {{")?;
        writeln!(out, "\tswitch ffi.tag {{")?;

        for case in &variant.cases {
            let c_tag = names::to_c_enum_variant(
                &names::to_c_type(&self.config.c_type_prefix, wit_name),
                &case.name,
            );
            let case_type_name = format!("{}{}", go_name, names::to_go_type(&case.name));
            let c_field = names::to_rust_ident(&case.name);

            writeln!(out, "\tcase C.{c_tag}:")?;
            if let Some(ty) = &case.ty {
                let payload = self.convert_variant_payload(ty, &c_field);
                writeln!(out, "\t\treturn {case_type_name}{{Value: {payload}}}")?;
            } else {
                writeln!(out, "\t\treturn {case_type_name}{{}}")?;
            }
        }

        writeln!(out, "\tdefault:")?;
        writeln!(
            out,
            "\t\tpanic(fmt.Sprintf(\"unknown {go_name} tag: %d\", ffi.tag))"
        )?;
        writeln!(out, "\t}}")?;
        writeln!(out, "}}")?;

        Ok(())
    }

    /// Generate a Go expression to convert a variant case payload.
    fn convert_variant_payload(&self, ty: &Type, c_field: &str) -> String {
        match ty {
            Type::String => {
                format!("ffiByteBufferToString(ffi.{c_field}.value)")
            }
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("ffiByteBufferToBytes(ffi.{c_field}.value)")
                    }
                    TypeDefKind::Type(aliased) => self.convert_variant_payload(aliased, c_field),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        let go_name = names::to_go_type(name);
                        format!("convert{go_name}(ffi.{c_field}.value)")
                    }
                }
            }
            _ => {
                // Primitive payload
                let go_ty = self.type_to_go(ty);
                format!("{go_ty}(ffi.{c_field}.value)")
            }
        }
    }

    /// Generate a Go expression to convert an FFI value to a Go value.
    fn convert_ffi_to_go(&self, ty: &Type, access: &str) -> String {
        match ty {
            Type::Bool => format!("bool({access})"),
            Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => {
                let go_ty = self.type_to_go(ty);
                format!("{go_ty}({access})")
            }
            Type::Char => format!("rune({access})"),
            Type::String => format!("ffiByteBufferToString({access})"),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        format!("ffiByteBufferToBytes({access})")
                    }
                    TypeDefKind::List(_) => {
                        format!("ffiByteBufferToBytes({access}) /* TODO: decode list elements */")
                    }
                    TypeDefKind::Type(aliased) => self.convert_ffi_to_go(aliased, access),
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        let go_name = names::to_go_type(name);
                        format!("convert{go_name}({access})")
                    }
                }
            }
            Type::ErrorContext => format!("string({access})"),
        }
    }

    /// Generate code for converting an optional (nullable pointer) FFI field.
    fn generate_optional_field_conversion(
        &self,
        out: &mut String,
        go_field: &str,
        c_field: &str,
        ty: &Type,
    ) -> std::fmt::Result {
        // Unwrap the Option layer to get the inner type
        let inner_ty = self.unwrap_option(ty);

        writeln!(out, "\tif ffi.{c_field} != nil {{")?;

        match inner_ty {
            Type::Bool
            | Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64 => {
                let go_ty = self.type_to_go(inner_ty);
                writeln!(out, "\t\tv := {go_ty}(*ffi.{c_field})")?;
                writeln!(out, "\t\tresult.{go_field} = &v")?;
                writeln!(out, "\t\tC.free(unsafe.Pointer(ffi.{c_field}))")?;
            }
            Type::String => {
                writeln!(out, "\t\tv := ffiByteBufferToString(*ffi.{c_field})")?;
                writeln!(out, "\t\tresult.{go_field} = &v")?;
                writeln!(out, "\t\tC.free(unsafe.Pointer(ffi.{c_field}))")?;
            }
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => {
                        writeln!(out, "\t\tv := ffiByteBufferToBytes(*ffi.{c_field})")?;
                        writeln!(out, "\t\tresult.{go_field} = v")?;
                        writeln!(out, "\t\tC.free(unsafe.Pointer(ffi.{c_field}))")?;
                    }
                    TypeDefKind::Type(aliased) => {
                        // Follow the alias and recurse
                        return self
                            .generate_optional_field_conversion(out, go_field, c_field, aliased);
                    }
                    _ => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        let go_name = names::to_go_type(name);
                        writeln!(out, "\t\tv := convert{go_name}(*ffi.{c_field})")?;
                        writeln!(out, "\t\tresult.{go_field} = &v")?;
                        writeln!(out, "\t\tC.free(unsafe.Pointer(ffi.{c_field}))")?;
                    }
                }
            }
            _ => {
                writeln!(out, "\t\tv := *ffi.{c_field}")?;
                writeln!(out, "\t\tresult.{go_field} = &v")?;
                writeln!(out, "\t\tC.free(unsafe.Pointer(ffi.{c_field}))")?;
            }
        }

        writeln!(out, "\t}}")?;

        Ok(())
    }

    /// Check if a type is `option<T>`.
    fn is_option_type(&self, ty: &Type) -> bool {
        if let Type::Id(id) = ty {
            let typedef = &self.resolve.types[*id];
            match &typedef.kind {
                TypeDefKind::Option(_) => true,
                TypeDefKind::Type(aliased) => self.is_option_type(aliased),
                _ => false,
            }
        } else {
            false
        }
    }

    /// Unwrap an `option<T>` to get the inner type `T`.
    /// If the type is not an option, returns the type itself.
    fn unwrap_option<'b>(&'b self, ty: &'b Type) -> &'b Type {
        if let Type::Id(id) = ty {
            let typedef = &self.resolve.types[*id];
            match &typedef.kind {
                TypeDefKind::Option(inner) => inner,
                TypeDefKind::Type(aliased) => self.unwrap_option(aliased),
                _ => ty,
            }
        } else {
            ty
        }
    }

    // ---- Public API generation ----

    fn generate_api(&self, out: &mut String) -> std::fmt::Result {
        writeln!(out, "// ---- Public API ----")?;

        let funcs = exported_functions(self.resolve, self.world_id);
        for ef in &funcs {
            self.generate_api_function(out, ef)?;
        }

        Ok(())
    }

    fn generate_api_function(&self, out: &mut String, ef: &ExportedFunction) -> std::fmt::Result {
        let c_func_name = if ef.interface_name.is_empty() {
            names::to_c_func(&self.config.c_prefix, &ef.function_name)
        } else {
            names::to_c_func(
                &self.config.c_prefix,
                &format!("{}_{}", ef.interface_name, ef.function_name),
            )
        };

        // Build the Go function name from interface + function
        let go_func_name = if ef.interface_name.is_empty() {
            names::to_go_func(&ef.function_name)
        } else {
            // For multi-interface worlds, combine interface + function name
            // e.g., "functions" + "u256-to-string" -> "FunctionsU256ToString"
            // But for single-function interfaces, just use the function name
            // for brevity (e.g., "parser" + "parse" -> "Parse")
            names::to_go_func(&format!("{}_{}", ef.interface_name, ef.function_name))
        };

        let result_decomposed = self.decompose_result(&ef.function.result);

        // Build Go parameters
        let go_params: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                let name = names::to_go_ident(&p.name);
                let ty = self.type_to_go(&p.ty);
                format!("{name} {ty}")
            })
            .collect();

        // Build return type
        let go_return = if let Some((ok_ty, _)) = &result_decomposed {
            let ret = ok_ty
                .as_ref()
                .map(|t| self.type_to_go(t))
                .unwrap_or_default();
            if ret.is_empty() {
                "error".to_string()
            } else {
                format!("({ret}, error)")
            }
        } else {
            ef.function
                .result
                .as_ref()
                .map(|t| self.type_to_go(t))
                .unwrap_or_default()
        };

        // Emit function signature
        writeln!(out)?;
        if let Some(docs) = &ef.function.docs.contents {
            Self::write_doc_comment(out, docs, "")?;
        }
        let return_clause = if go_return.is_empty() {
            String::new()
        } else {
            format!(" {go_return}")
        };
        writeln!(
            out,
            "func {go_func_name}({params}){return_clause} {{",
            params = go_params.join(", ")
        )?;

        // Generate the function body
        self.generate_api_function_body(out, ef, &c_func_name, &result_decomposed)?;

        writeln!(out, "}}")?;

        Ok(())
    }

    fn generate_api_function_body(
        &self,
        out: &mut String,
        ef: &ExportedFunction,
        c_func_name: &str,
        result_decomposed: &Option<(Option<Type>, Option<Type>)>,
    ) -> std::fmt::Result {
        // Marshal input parameters
        for p in &ef.function.params {
            self.generate_param_marshaling(out, &p.name, &p.ty)?;
        }

        // Build C function call arguments
        let c_args: Vec<String> = ef
            .function
            .params
            .iter()
            .map(|p| {
                let name = names::to_go_ident(&p.name);
                if self.param_needs_marshaling(&p.ty) {
                    format!("{name}Slice")
                } else {
                    let cgo_ty = self.type_to_cgo(&p.ty);
                    format!("{cgo_ty}({name})")
                }
            })
            .collect();
        let c_args_str = c_args.join(", ");

        // Call C function and handle result
        if let Some((ok_ty, _)) = result_decomposed {
            if let Some(ok_type) = ok_ty {
                // result<T, E> with a value — returns pointer (null = error)
                writeln!(out, "\tresultPtr := C.{c_func_name}({c_args_str})")?;
                writeln!(out, "\tif resultPtr == nil {{")?;
                let zero_val = self.go_zero_value(ok_type);
                writeln!(
                    out,
                    "\t\treturn {zero_val}, fmt.Errorf(\"{c_func_name} failed: %s\", readLastError())"
                )?;
                writeln!(out, "\t}}")?;
                let conversion = self.convert_ffi_to_go(ok_type, "*resultPtr");
                writeln!(out, "\tresult := {conversion}")?;
                // Free with type-specific free function
                let free_func = self.result_free_func(ok_type);
                writeln!(out, "\tC.{free_func}(resultPtr)")?;
                writeln!(out, "\treturn result, nil")?;
            } else {
                // result<_, E> with no ok value — returns bool
                writeln!(out, "\tsuccess := C.{c_func_name}({c_args_str})")?;
                writeln!(out, "\tif !success {{")?;
                writeln!(
                    out,
                    "\t\treturn fmt.Errorf(\"{c_func_name} failed: %s\", readLastError())"
                )?;
                writeln!(out, "\t}}")?;
                writeln!(out, "\treturn nil")?;
            }
        } else if let Some(ret_ty) = &ef.function.result {
            // Non-result return type — direct conversion
            writeln!(out, "\tresult := C.{c_func_name}({c_args_str})")?;
            let conversion = self.convert_ffi_to_go(ret_ty, "result");
            writeln!(out, "\treturn {conversion}")?;
        } else {
            // Void return
            writeln!(out, "\tC.{c_func_name}({c_args_str})")?;
        }

        Ok(())
    }

    /// Generate Go code to marshal a parameter into an FfiByteSlice.
    fn generate_param_marshaling(
        &self,
        out: &mut String,
        param_name: &str,
        ty: &Type,
    ) -> std::fmt::Result {
        let go_name = names::to_go_ident(param_name);

        if !self.param_needs_marshaling(ty) {
            return Ok(());
        }

        match self.resolve_to_leaf(ty) {
            Type::String => {
                writeln!(out, "\t{go_name}Slice := C.FfiByteSlice{{")?;
                writeln!(
                    out,
                    "\t\tptr: (*C.uint8_t)(unsafe.Pointer(unsafe.StringData({go_name}))),",
                )?;
                writeln!(out, "\t\tlen: C.uintptr_t(len({go_name})),")?;
                writeln!(out, "\t}}")?;
            }
            _ => {
                // list<u8> or other byte-slice types
                writeln!(out, "\t{go_name}Slice := C.FfiByteSlice{{")?;
                writeln!(
                    out,
                    "\t\tptr: (*C.uint8_t)(unsafe.Pointer(unsafe.SliceData({go_name}))),",
                )?;
                writeln!(out, "\t\tlen: C.uintptr_t(len({go_name})),")?;
                writeln!(out, "\t}}")?;
            }
        }

        Ok(())
    }

    /// Check if a parameter type needs marshaling (String/[]byte → FfiByteSlice).
    fn param_needs_marshaling(&self, ty: &Type) -> bool {
        match ty {
            Type::String => true,
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(Type::U8) => true,
                    TypeDefKind::Type(aliased) => self.param_needs_marshaling(aliased),
                    _ => false,
                }
            }
            _ => false,
        }
    }

    /// Follow type aliases to the leaf type.
    fn resolve_to_leaf<'b>(&'b self, ty: &'b Type) -> &'b Type {
        if let Type::Id(id) = ty {
            let typedef = &self.resolve.types[*id];
            if let TypeDefKind::Type(aliased) = &typedef.kind {
                return self.resolve_to_leaf(aliased);
            }
        }
        ty
    }

    /// Get the Go zero value for a type (used in error returns).
    fn go_zero_value(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "false".to_string(),
            Type::U8
            | Type::U16
            | Type::U32
            | Type::U64
            | Type::S8
            | Type::S16
            | Type::S32
            | Type::S64
            | Type::F32
            | Type::F64
            | Type::Char => "0".to_string(),
            Type::String => "\"\"".to_string(),
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::List(_) => "nil".to_string(),
                    TypeDefKind::Option(_) => "nil".to_string(),
                    TypeDefKind::Variant(_) => "nil".to_string(),
                    TypeDefKind::Type(aliased) => self.go_zero_value(aliased),
                    TypeDefKind::Record(_) => {
                        let name = typedef.name.as_deref().unwrap_or("Anonymous");
                        format!("{}{{}}", names::to_go_type(name))
                    }
                    TypeDefKind::Enum(_) | TypeDefKind::Flags(_) => "0".to_string(),
                    _ => "nil".to_string(),
                }
            }
            Type::ErrorContext => "\"\"".to_string(),
        }
    }

    /// Get the C free function name for a result ok type.
    fn result_free_func(&self, ty: &Type) -> String {
        match ty {
            Type::Id(id) => {
                let typedef = &self.resolve.types[*id];
                match &typedef.kind {
                    TypeDefKind::Record(_) | TypeDefKind::Variant(_) => {
                        let name = typedef.name.as_deref().unwrap_or("anonymous");
                        names::to_c_func(&self.config.c_prefix, &format!("free-{name}"))
                    }
                    TypeDefKind::Type(aliased) => self.result_free_func(aliased),
                    _ => format!("{}_free_byte_buffer", self.c_func_prefix()),
                }
            }
            Type::String => format!("{}_free_byte_buffer", self.c_func_prefix()),
            _ => "free".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::path::Path;

    use super::*;

    #[test]
    fn test_generate_go_from_eip681() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) =
            witffi_core::load_wit(&wit_path).expect("failed to load eip681.wit");

        let config = GoConfig {
            c_prefix: "zcash_eip681".to_string(),
            c_type_prefix: "Ffi".to_string(),
            go_package: None,
            lib_name: "eip681_ffi".to_string(),
        };

        let generator = GoGenerator::new(&resolve, world_id, config);
        let code = generator.generate().expect("failed to generate Go code");

        eprintln!("--- Generated Go code ---\n{code}\n--- End ---");

        // Package declaration
        assert!(
            code.contains("package eip681"),
            "missing package declaration"
        );

        // CGo preamble
        assert!(
            code.contains("#cgo LDFLAGS: -leip681_ffi"),
            "missing cgo LDFLAGS"
        );
        assert!(code.contains("import \"C\""), "missing import C");

        // Helpers
        assert!(
            code.contains("func ffiByteBufferToString"),
            "missing ffiByteBufferToString"
        );
        assert!(
            code.contains("func ffiByteBufferToBytes"),
            "missing ffiByteBufferToBytes"
        );
        assert!(code.contains("func readLastError"), "missing readLastError");

        // Types
        assert!(
            code.contains("type NativeRequest struct"),
            "missing NativeRequest"
        );
        assert!(
            code.contains("type Erc20Request struct"),
            "missing Erc20Request"
        );
        assert!(
            code.contains("type transactionRequestVariant interface"),
            "missing variant interface"
        );
        assert!(
            code.contains("type TransactionRequestNative struct"),
            "missing TransactionRequestNative"
        );
        assert!(
            code.contains("type TransactionRequest = transactionRequestVariant"),
            "missing TransactionRequest alias"
        );

        // Conversion functions
        assert!(
            code.contains("func convertNativeRequest"),
            "missing convertNativeRequest"
        );
        assert!(
            code.contains("func convertTransactionRequest"),
            "missing convertTransactionRequest"
        );

        // Public API — parser interface
        assert!(
            code.contains("func ParserParse("),
            "missing ParserParse function"
        );
        assert!(
            code.contains("(TransactionRequest, error)"),
            "missing result return type"
        );

        // Public API — functions interface
        assert!(
            code.contains("func FunctionsU256ToString("),
            "missing FunctionsU256ToString function"
        );
        assert!(
            code.contains("C.zcash_eip681_functions_u256_to_string"),
            "missing C call for u256_to_string"
        );
    }

    #[test]
    fn test_go_type_mapping() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) =
            witffi_core::load_wit(&wit_path).expect("failed to load eip681.wit");

        let config = GoConfig::default();
        let generator = GoGenerator::new(&resolve, world_id, config);

        assert_eq!(generator.type_to_go(&Type::String), "string");
        assert_eq!(generator.type_to_go(&Type::Bool), "bool");
        assert_eq!(generator.type_to_go(&Type::U64), "uint64");
        assert_eq!(generator.type_to_go(&Type::S32), "int32");
        assert_eq!(generator.type_to_go(&Type::F64), "float64");
    }

    #[test]
    fn test_go_package_name_derivation() {
        let wit_path = Path::new(env!("CARGO_MANIFEST_DIR")).join("../../wit/eip681.wit");
        let (resolve, world_id) =
            witffi_core::load_wit(&wit_path).expect("failed to load eip681.wit");

        // Default: derived from world name
        let config = GoConfig {
            go_package: None,
            ..GoConfig::default()
        };
        let generator = GoGenerator::new(&resolve, world_id, config);
        assert_eq!(generator.package_name(), "eip681");

        // Override
        let config2 = GoConfig {
            go_package: Some("mypkg".to_string()),
            ..GoConfig::default()
        };
        let generator2 = GoGenerator::new(&resolve, world_id, config2);
        assert_eq!(generator2.package_name(), "mypkg");
    }
}
