// Auto-generated by witffi. Do not edit.

// ---- FFI-safe types ----
//
// FfiByteSlice and FfiByteBuffer are provided by the `witffi-types` crate.

/// A native ETH transfer request.
#[repr(C)]
#[derive(Debug)]
pub struct FfiNativeRequest {
    /// The schema prefix (e.g. "ethereum").
    pub schema_prefix: witffi_types::FfiByteBuffer,
    /// The chain ID, if specified.
    pub chain_id: *mut u64,
    /// The recipient address (ERC-55 checksummed hex string).
    pub recipient_address: witffi_types::FfiByteBuffer,
    /// The value in atomic units (wei), if specified.
    pub value_atomic: *mut witffi_types::FfiByteBuffer,
    /// The gas limit, if specified.
    pub gas_limit: *mut witffi_types::FfiByteBuffer,
    /// The gas price, if specified.
    pub gas_price: *mut witffi_types::FfiByteBuffer,
    /// The canonical display string (round-trips through parsing).
    pub display: witffi_types::FfiByteBuffer,
}

/// An ERC-20 token transfer request.
#[repr(C)]
#[derive(Debug)]
pub struct FfiErc20Request {
    /// The chain ID, if specified.
    pub chain_id: *mut u64,
    /// The token contract address (ERC-55 checksummed hex string).
    pub token_contract_address: witffi_types::FfiByteBuffer,
    /// The recipient address.
    pub recipient_address: witffi_types::FfiByteBuffer,
    /// The value in atomic token units.
    pub value_atomic: witffi_types::FfiByteBuffer,
    /// The canonical display string.
    pub display: witffi_types::FfiByteBuffer,
}

#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FfiTransactionRequestTag {
    Native = 0,
    Erc20 = 1,
    Unrecognised = 2,
}

#[repr(C)]
#[derive(Debug)]
pub struct FfiTransactionRequestNativePayload {
    pub value: FfiNativeRequest,
}

#[repr(C)]
#[derive(Debug)]
pub struct FfiTransactionRequestErc20Payload {
    pub value: FfiErc20Request,
}

#[repr(C)]
#[derive(Debug)]
pub struct FfiTransactionRequestUnrecognisedPayload {
    pub value: witffi_types::FfiByteBuffer,
}

/// A parsed EIP-681 transaction request.
#[repr(C)]
#[derive(Debug)]
pub struct FfiTransactionRequest {
    pub tag: FfiTransactionRequestTag,
    /// Valid when tag == FfiTransactionRequestTag::Native
    pub native: *mut FfiTransactionRequestNativePayload,
    /// Valid when tag == FfiTransactionRequestTag::Erc20
    pub erc20: *mut FfiTransactionRequestErc20Payload,
    /// Valid when tag == FfiTransactionRequestTag::Unrecognised
    pub unrecognised: *mut FfiTransactionRequestUnrecognisedPayload,
}

// ---- Implementation trait ----

/// Trait that library authors implement to provide the FFI functions.
/// Each method corresponds to a WIT exported function.
pub trait Eip681 {
    fn parser_parse(input: &str) -> Result<FfiTransactionRequest, String>;
}

// ---- Free functions ----

/// Free an `FfiByteBuffer` returned by an FFI function.
///
/// # Safety
/// The buffer must have been allocated by this library.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn zcash_eip681_free_byte_buffer(buf: witffi_types::FfiByteBuffer) {
    unsafe { buf.free() };
}

/// Free a `FfiNativeRequest` returned by an FFI function.
///
/// # Safety
/// The pointer must have been allocated by this library.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn zcash_eip681_free_native_request(ptr: *mut FfiNativeRequest) {
    unsafe { witffi_types::free_ptr(ptr) };
}

/// Free a `FfiErc20Request` returned by an FFI function.
///
/// # Safety
/// The pointer must have been allocated by this library.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn zcash_eip681_free_erc20_request(ptr: *mut FfiErc20Request) {
    unsafe { witffi_types::free_ptr(ptr) };
}

/// Free a `FfiTransactionRequest` returned by an FFI function.
///
/// # Safety
/// The pointer must have been allocated by this library.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn zcash_eip681_free_transaction_request(ptr: *mut FfiTransactionRequest) {
    unsafe { witffi_types::free_ptr(ptr) };
}

// ---- Registration macro ----

/// Register a concrete type that implements the [`Eip681`] trait.
///
/// This macro generates all `extern "C"` FFI functions that delegate
/// to the trait implementation, handling parameter conversion, error
/// storage, and panic catching.
///
/// # Example
///
/// ```ignore
/// struct MyImpl;
/// impl Eip681 for MyImpl {
///     // ... implement trait methods ...
/// }
/// witffi_register!(MyImpl);
/// ```
#[macro_export]
macro_rules! witffi_register {
    ($impl_type:ty) => {

        // Last error message stored for FFI error reporting.
        std::thread_local! {
            static LAST_ERROR: std::cell::RefCell<Option<String>> = const { std::cell::RefCell::new(None) };
        }

        // Get the length of the last error message (0 if no error).
        #[unsafe(no_mangle)]
        pub extern "C" fn zcash_eip681_last_error_length() -> i32 {
            LAST_ERROR.with(|e| {
                e.borrow().as_ref().map(|s| s.len() as i32 + 1).unwrap_or(0)
            })
        }

        // Copy the last error message into the provided buffer.
        // Safety: `buf` must point to `len` bytes of writable memory.
        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_error_message_utf8(buf: *mut std::os::raw::c_char, len: i32) -> i32 {
            LAST_ERROR.with(|e| {
                match e.borrow().as_ref() {
                    Some(msg) => {
                        let c_msg = match std::ffi::CString::new(msg.as_str()) {
                            Ok(c) => c,
                            Err(_) => return -1,
                        };
                        let bytes = c_msg.as_bytes_with_nul();
                        let copy_len = bytes.len().min(len as usize);
                        unsafe { std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf as *mut u8, copy_len) };
                        copy_len as i32
                    }
                    None => 0,
                }
            })
        }

        // Clear the last error.
        #[unsafe(no_mangle)]
        pub extern "C" fn zcash_eip681_clear_last_error() {
            LAST_ERROR.with(|e| *e.borrow_mut() = None);
        }

        // FFI wrapper for `parser.parse`.
        // Safety: All pointer parameters must be valid for the given lengths.
        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_parser_parse(input: witffi_types::FfiByteSlice) -> *mut FfiTransactionRequest {
            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                let input_rust = unsafe { input.as_str_unchecked() };
                <$impl_type>::parser_parse(input_rust)
            }));

            match result {
                Ok(Ok(value)) => {
                    LAST_ERROR.with(|e| *e.borrow_mut() = None);
                    Box::into_raw(Box::new(value))
                }
                Ok(Err(e)) => {
                    LAST_ERROR.with(|e_cell| *e_cell.borrow_mut() = Some(format!("{e}")));
                    std::ptr::null_mut()
                }
                Err(panic) => {
                    let msg = if let Some(s) = panic.downcast_ref::<&str>() {
                        s.to_string()
                    } else if let Some(s) = panic.downcast_ref::<String>() {
                        s.clone()
                    } else {
                        "unknown panic".to_string()
                    };
                    LAST_ERROR.with(|e| *e.borrow_mut() = Some(msg));
                    std::ptr::null_mut()
                }
            }
        }

    };
}
