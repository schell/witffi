// Auto-generated by witffi. Do not edit.

// ---- Idiomatic Rust types ----

/// A native ETH transfer request.
#[derive(Debug, Clone)]
pub struct NativeRequest {
    /// The schema prefix (e.g. "ethereum").
    pub schema_prefix: String,
    /// The chain ID, if specified.
    pub chain_id: Option<u64>,
    /// The recipient address (ERC-55 checksummed hex string).
    pub recipient_address: String,
    /// The value in atomic units (wei), if specified.
    pub value_atomic: Option<Vec<u8>>,
    /// The gas limit, if specified.
    pub gas_limit: Option<Vec<u8>>,
    /// The gas price, if specified.
    pub gas_price: Option<Vec<u8>>,
    /// The canonical display string (round-trips through parsing).
    pub display: String,
}

/// An ERC-20 token transfer request.
#[derive(Debug, Clone)]
pub struct Erc20Request {
    /// The chain ID, if specified.
    pub chain_id: Option<u64>,
    /// The token contract address (ERC-55 checksummed hex string).
    pub token_contract_address: String,
    /// The recipient address.
    pub recipient_address: String,
    /// The value in atomic token units.
    pub value_atomic: Vec<u8>,
    /// The canonical display string.
    pub display: String,
}

/// A parsed EIP-681 transaction request.
#[derive(Debug, Clone)]
pub enum TransactionRequest {
    /// A native ETH transfer.
    Native(NativeRequest),
    /// An ERC-20 token transfer.
    Erc20(Erc20Request),
    /// An unrecognised request (raw URI string preserved).
    Unrecognised(String),
}

// ---- Implementation trait ----

/// Trait that library authors implement to provide the FFI functions.
/// Each method corresponds to a WIT exported function.
pub trait Eip681 {
    fn parser_parse(input: &str) -> Result<TransactionRequest, String>;
}
// ---- C-ABI Registration macro ----

/// Register a concrete type for C-ABI FFI (Swift, Go, C consumers).
///
/// This macro generates `#[repr(C)]` shadow types, conversion logic,
/// `extern "C"` wrapper functions, error handling, and free functions.
///
/// # Example
///
/// ```ignore
/// struct MyImpl;
/// impl Eip681 for MyImpl {
///     // ... implement trait methods ...
/// }
/// witffi_register_ffi!(MyImpl);
/// ```
#[macro_export]
macro_rules! witffi_register_ffi {
    ($impl_type:ty) => {

        // ---- repr(C) shadow types for C-ABI ----

        #[repr(C)]
        #[derive(Debug)]
        pub struct FfiNativeRequest {
            pub schema_prefix: witffi_types::FfiByteBuffer,
            pub chain_id: *mut u64,
            pub recipient_address: witffi_types::FfiByteBuffer,
            pub value_atomic: *mut witffi_types::FfiByteBuffer,
            pub gas_limit: *mut witffi_types::FfiByteBuffer,
            pub gas_price: *mut witffi_types::FfiByteBuffer,
            pub display: witffi_types::FfiByteBuffer,
        }

        #[repr(C)]
        #[derive(Debug)]
        pub struct FfiErc20Request {
            pub chain_id: *mut u64,
            pub token_contract_address: witffi_types::FfiByteBuffer,
            pub recipient_address: witffi_types::FfiByteBuffer,
            pub value_atomic: witffi_types::FfiByteBuffer,
            pub display: witffi_types::FfiByteBuffer,
        }

        #[repr(u32)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        pub enum FfiTransactionRequestTag {
            Native = 0,
            Erc20 = 1,
            Unrecognised = 2,
        }

        #[repr(C)]
        #[derive(Debug)]
        pub struct FfiTransactionRequestNativePayload {
            pub value: FfiNativeRequest,
        }

        #[repr(C)]
        #[derive(Debug)]
        pub struct FfiTransactionRequestErc20Payload {
            pub value: FfiErc20Request,
        }

        #[repr(C)]
        #[derive(Debug)]
        pub struct FfiTransactionRequestUnrecognisedPayload {
            pub value: witffi_types::FfiByteBuffer,
        }

        #[repr(C)]
        #[derive(Debug)]
        pub struct FfiTransactionRequest {
            pub tag: FfiTransactionRequestTag,
            pub native: *mut FfiTransactionRequestNativePayload,
            pub erc20: *mut FfiTransactionRequestErc20Payload,
            pub unrecognised: *mut FfiTransactionRequestUnrecognisedPayload,
        }

        // ---- Conversions: idiomatic -> repr(C) ----

        fn native_request_to_ffi(v: NativeRequest) -> FfiNativeRequest {
            FfiNativeRequest {
                schema_prefix: witffi_types::FfiByteBuffer::from_string(v.schema_prefix),
                chain_id: witffi_types::option_to_ptr(v.chain_id.map(|v| v)),
                recipient_address: witffi_types::FfiByteBuffer::from_string(v.recipient_address),
                value_atomic: witffi_types::option_to_ptr(v.value_atomic.map(|v| witffi_types::FfiByteBuffer::from_vec(v))),
                gas_limit: witffi_types::option_to_ptr(v.gas_limit.map(|v| witffi_types::FfiByteBuffer::from_vec(v))),
                gas_price: witffi_types::option_to_ptr(v.gas_price.map(|v| witffi_types::FfiByteBuffer::from_vec(v))),
                display: witffi_types::FfiByteBuffer::from_string(v.display),
            }
        }

        fn erc20_request_to_ffi(v: Erc20Request) -> FfiErc20Request {
            FfiErc20Request {
                chain_id: witffi_types::option_to_ptr(v.chain_id.map(|v| v)),
                token_contract_address: witffi_types::FfiByteBuffer::from_string(v.token_contract_address),
                recipient_address: witffi_types::FfiByteBuffer::from_string(v.recipient_address),
                value_atomic: witffi_types::FfiByteBuffer::from_vec(v.value_atomic),
                display: witffi_types::FfiByteBuffer::from_string(v.display),
            }
        }

        fn transaction_request_to_ffi(v: TransactionRequest) -> FfiTransactionRequest {
            match v {
                TransactionRequest::Native(inner) => FfiTransactionRequest {
                    tag: FfiTransactionRequestTag::Native,
                    native: Box::into_raw(Box::new(FfiTransactionRequestNativePayload { value: native_request_to_ffi(inner) })),
                    erc20: std::ptr::null_mut(),
                    unrecognised: std::ptr::null_mut(),
                },
                TransactionRequest::Erc20(inner) => FfiTransactionRequest {
                    tag: FfiTransactionRequestTag::Erc20,
                    native: std::ptr::null_mut(),
                    erc20: Box::into_raw(Box::new(FfiTransactionRequestErc20Payload { value: erc20_request_to_ffi(inner) })),
                    unrecognised: std::ptr::null_mut(),
                },
                TransactionRequest::Unrecognised(inner) => FfiTransactionRequest {
                    tag: FfiTransactionRequestTag::Unrecognised,
                    native: std::ptr::null_mut(),
                    erc20: std::ptr::null_mut(),
                    unrecognised: Box::into_raw(Box::new(FfiTransactionRequestUnrecognisedPayload { value: witffi_types::FfiByteBuffer::from_string(inner) })),
                },
            }
        }

        // ---- Free functions ----

        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_free_byte_buffer(buf: witffi_types::FfiByteBuffer) {
            unsafe { buf.free() };
        }

        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_free_native_request(ptr: *mut FfiNativeRequest) {
            unsafe { witffi_types::free_ptr(ptr) };
        }

        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_free_erc20_request(ptr: *mut FfiErc20Request) {
            unsafe { witffi_types::free_ptr(ptr) };
        }

        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_free_transaction_request(ptr: *mut FfiTransactionRequest) {
            unsafe { witffi_types::free_ptr(ptr) };
        }

        // Last error message stored for FFI error reporting.
        std::thread_local! {
            static LAST_ERROR: std::cell::RefCell<Option<String>> = const { std::cell::RefCell::new(None) };
        }

        #[unsafe(no_mangle)]
        pub extern "C" fn zcash_eip681_last_error_length() -> i32 {
            LAST_ERROR.with(|e| {
                e.borrow().as_ref().map(|s| s.len() as i32 + 1).unwrap_or(0)
            })
        }

        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_error_message_utf8(buf: *mut std::os::raw::c_char, len: i32) -> i32 {
            LAST_ERROR.with(|e| {
                match e.borrow().as_ref() {
                    Some(msg) => {
                        let c_msg = match std::ffi::CString::new(msg.as_str()) {
                            Ok(c) => c,
                            Err(_) => return -1,
                        };
                        let bytes = c_msg.as_bytes_with_nul();
                        let copy_len = bytes.len().min(len as usize);
                        unsafe { std::ptr::copy_nonoverlapping(bytes.as_ptr(), buf as *mut u8, copy_len) };
                        copy_len as i32
                    }
                    None => 0,
                }
            })
        }

        #[unsafe(no_mangle)]
        pub extern "C" fn zcash_eip681_clear_last_error() {
            LAST_ERROR.with(|e| *e.borrow_mut() = None);
        }

        #[allow(clippy::missing_safety_doc)]
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn zcash_eip681_parser_parse(input: witffi_types::FfiByteSlice) -> *mut FfiTransactionRequest {
            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                let input_rust = unsafe { input.as_str_unchecked() };
                <$impl_type>::parser_parse(input_rust)
            }));

            match result {
                Ok(Ok(value)) => {
                    LAST_ERROR.with(|e| *e.borrow_mut() = None);
                    Box::into_raw(Box::new(transaction_request_to_ffi(value)))
                }
                Ok(Err(e)) => {
                    LAST_ERROR.with(|e_cell| *e_cell.borrow_mut() = Some(format!("{e}")));
                    std::ptr::null_mut()
                }
                Err(panic) => {
                    let msg = if let Some(s) = panic.downcast_ref::<&str>() {
                        s.to_string()
                    } else if let Some(s) = panic.downcast_ref::<String>() {
                        s.clone()
                    } else {
                        "unknown panic".to_string()
                    };
                    LAST_ERROR.with(|e| *e.borrow_mut() = Some(msg));
                    std::ptr::null_mut()
                }
            }
        }

    };
}

/// Backward-compatible alias for [`witffi_register_ffi!`].
#[macro_export]
macro_rules! witffi_register {
    ($impl_type:ty) => {
        witffi_register_ffi!($impl_type);
    };
}
// ---- JNI Registration macro ----

/// Register a concrete type for JNI (Kotlin/Android consumers).
///
/// This macro generates `Java_` JNI entry points, JVM object
/// construction helpers, and exception-based error handling.
///
/// Requires the `jni` crate as a dependency of the FFI crate.
///
/// # Example
///
/// ```ignore
/// struct MyImpl;
/// impl Eip681 for MyImpl {
///     // ... implement trait methods ...
/// }
/// witffi_register_jni!(MyImpl);
/// ```
#[macro_export]
macro_rules! witffi_register_jni {
    ($impl_type:ty) => {

        // ---- JNI conversion helpers ----

        fn to_jni_native_request<'local>(
            env: &mut jni::JNIEnv<'local>,
            value: &NativeRequest,
        ) -> jni::errors::Result<jni::objects::JObject<'local>> {
            let _schema_prefix = env.new_string(&value.schema_prefix)?;
            let _chain_id = match &value.chain_id { Some(v) => env.new_object("java/lang/Long", "(J)V", &[jni::objects::JValue::Long(*v as i64)])?, None => jni::objects::JObject::null() };
            let _recipient_address = env.new_string(&value.recipient_address)?;
            let _value_atomic = match &value.value_atomic { Some(v) => { let _v = env.byte_array_from_slice(&v)?; jni::objects::JObject::from(_v) }, None => jni::objects::JObject::null() };
            let _gas_limit = match &value.gas_limit { Some(v) => { let _v = env.byte_array_from_slice(&v)?; jni::objects::JObject::from(_v) }, None => jni::objects::JObject::null() };
            let _gas_price = match &value.gas_price { Some(v) => { let _v = env.byte_array_from_slice(&v)?; jni::objects::JObject::from(_v) }, None => jni::objects::JObject::null() };
            let _display = env.new_string(&value.display)?;
            let args: &[jni::objects::JValue] = &[
                jni::objects::JValue::Object(&_schema_prefix),
                jni::objects::JValue::Object(&_chain_id),
                jni::objects::JValue::Object(&_recipient_address),
                jni::objects::JValue::Object(&_value_atomic),
                jni::objects::JValue::Object(&_gas_limit),
                jni::objects::JValue::Object(&_gas_price),
                jni::objects::JValue::Object(&_display),
            ];
            env.new_object("zcash/eip681/NativeRequest", "(Ljava/lang/String;Ljava/lang/Long;Ljava/lang/String;[B[B[BLjava/lang/String;)V", args)
        }

        fn to_jni_erc20_request<'local>(
            env: &mut jni::JNIEnv<'local>,
            value: &Erc20Request,
        ) -> jni::errors::Result<jni::objects::JObject<'local>> {
            let _chain_id = match &value.chain_id { Some(v) => env.new_object("java/lang/Long", "(J)V", &[jni::objects::JValue::Long(*v as i64)])?, None => jni::objects::JObject::null() };
            let _token_contract_address = env.new_string(&value.token_contract_address)?;
            let _recipient_address = env.new_string(&value.recipient_address)?;
            let _value_atomic = env.byte_array_from_slice(&value.value_atomic)?;
            let _display = env.new_string(&value.display)?;
            let args: &[jni::objects::JValue] = &[
                jni::objects::JValue::Object(&_chain_id),
                jni::objects::JValue::Object(&_token_contract_address),
                jni::objects::JValue::Object(&_recipient_address),
                jni::objects::JValue::Object(&_value_atomic),
                jni::objects::JValue::Object(&_display),
            ];
            env.new_object("zcash/eip681/Erc20Request", "(Ljava/lang/Long;Ljava/lang/String;Ljava/lang/String;[BLjava/lang/String;)V", args)
        }

        fn to_jni_transaction_request<'local>(
            env: &mut jni::JNIEnv<'local>,
            value: &TransactionRequest,
        ) -> jni::errors::Result<jni::objects::JObject<'local>> {
            match value {
                TransactionRequest::Native(inner) => {
                    let _inner = to_jni_native_request(env, &inner)?;
                    env.new_object("zcash/eip681/TransactionRequest$Native", "(Lzcash/eip681/NativeRequest;)V", &[jni::objects::JValue::Object(&_inner)])
                }
                TransactionRequest::Erc20(inner) => {
                    let _inner = to_jni_erc20_request(env, &inner)?;
                    env.new_object("zcash/eip681/TransactionRequest$Erc20", "(Lzcash/eip681/Erc20Request;)V", &[jni::objects::JValue::Object(&_inner)])
                }
                TransactionRequest::Unrecognised(inner) => {
                    let _inner = env.new_string(&inner)?;
                    env.new_object("zcash/eip681/TransactionRequest$Unrecognised", "(Ljava/lang/String;)V", &[jni::objects::JValue::Object(&_inner)])
                }
            }
        }

        #[unsafe(no_mangle)]
        pub extern "C" fn Java_zcash_eip681_Eip681_00024Companion_nativeParserParse<'local>(
            mut env: jni::JNIEnv<'local>,
            _class: jni::objects::JClass<'local>,
            input: jni::objects::JString<'local>,
        ) -> jni::sys::jobject {
            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                let input_rust: String = env.get_string(&input).map_err(|e| e.to_string())?.into();
                <$impl_type>::parser_parse(input_rust)
            }));

            match result {
                Ok(Ok(value)) => {
                    match (|| -> jni::errors::Result<_> { Ok(to_jni_transaction_request(env, &value)?) })() {
                        Ok(obj) => obj.into_raw(),
                        Err(e) => {
                            let _ = env.throw_new("java/lang/RuntimeException", format!("{e}"));
                            std::ptr::null_mut()
                        }
                    }
                }
                Ok(Err(e)) => {
                    let _ = env.throw_new("java/lang/RuntimeException", format!("{e}"));
                    std::ptr::null_mut()
                }
                Err(_panic) => {
                    let _ = env.throw_new("java/lang/RuntimeException", "Rust panic");
                    std::ptr::null_mut()
                }
            }
        }

    };
}
