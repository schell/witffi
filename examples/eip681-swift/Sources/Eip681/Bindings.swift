// Auto-generated by witffi. Do not edit.

import CZcashEip681
import Foundation

// MARK: - Error Type

/// An error returned by the FFI layer.
public struct WitFFIError: Error, CustomStringConvertible {
    /// The error message from the FFI layer.
    public let message: String

    public var description: String { message }

    /// Read the last error from the FFI thread-local storage.
    internal static func readLastError() -> WitFFIError {
        let len = zcash_eip681_last_error_length()
        guard len > 0 else {
            return WitFFIError(message: "unknown error")
        }
        var buf = [CChar](repeating: 0, count: Int(len))
        let copied = zcash_eip681_error_message_utf8(&buf, len)
        if copied > 0 {
            let msg = buf.withUnsafeBufferPointer { ptr in
                String(decoding: UnsafeRawBufferPointer(ptr).prefix(Int(copied - 1)), as: UTF8.self)
            }
            return WitFFIError(message: msg)
        } else {
            return WitFFIError(message: "unknown error")
        }
    }
}

// MARK: - Internal Helpers

/// Convert an `FfiByteBuffer` to a Swift `String`, freeing the buffer.
private func ffiByteBufferToString(_ buf: FfiByteBuffer) -> String {
    if buf.ptr == nil || buf.len == 0 {
        if buf.ptr != nil {
            let copy = buf
            zcash_eip681_free_byte_buffer(copy)
        }
        return ""
    }
    let data = Data(bytes: buf.ptr, count: buf.len)
    let copy = buf
    zcash_eip681_free_byte_buffer(copy)
    return String(data: data, encoding: .utf8) ?? ""
}

/// Convert an `FfiByteBuffer` to a Swift `Data`, freeing the buffer.
private func ffiByteBufferToData(_ buf: FfiByteBuffer) -> Data {
    if buf.ptr == nil || buf.len == 0 {
        if buf.ptr != nil {
            let copy = buf
            zcash_eip681_free_byte_buffer(copy)
        }
        return Data()
    }
    let data = Data(bytes: buf.ptr, count: buf.len)
    let copy = buf
    zcash_eip681_free_byte_buffer(copy)
    return data
}

// MARK: - Types

/// A native ETH transfer request.
public struct NativeRequest {
    /// The schema prefix (e.g. "ethereum").
    public let schemaPrefix: String
    /// The chain ID, if specified.
    public let chainId: UInt64?
    /// The recipient address (ERC-55 checksummed hex string).
    public let recipientAddress: String
    /// The value in atomic units (wei), if specified.
    public let valueAtomic: Data?
    /// The gas limit, if specified.
    public let gasLimit: Data?
    /// The gas price, if specified.
    public let gasPrice: Data?
    /// The canonical display string (round-trips through parsing).
    public let display: String
}

/// An ERC-20 token transfer request.
public struct Erc20Request {
    /// The chain ID, if specified.
    public let chainId: UInt64?
    /// The token contract address (ERC-55 checksummed hex string).
    public let tokenContractAddress: String
    /// The recipient address.
    public let recipientAddress: String
    /// The value in atomic token units.
    public let valueAtomic: Data
    /// The canonical display string.
    public let display: String
}

/// A parsed EIP-681 transaction request.
public enum TransactionRequest {
    /// A native ETH transfer.
    case native(NativeRequest)
    /// An ERC-20 token transfer.
    case erc20(Erc20Request)
    /// An unrecognised request (raw URI string preserved).
    case unrecognised(String)
}

// MARK: - FFI Conversion Functions

/// Convert a C `FfiNativeRequest` to a Swift `NativeRequest`, freeing the C memory.
private func convertNativeRequest(_ ffi: FfiNativeRequest) -> NativeRequest {
    return NativeRequest(
        schemaPrefix: ffiByteBufferToString(ffi.schema_prefix),
        chainId: (ffi.chain_id).map({ ptr in ptr.pointee }),
        recipientAddress: ffiByteBufferToString(ffi.recipient_address),
        valueAtomic: (ffi.value_atomic).map({ ptr in ffiByteBufferToData(ptr.pointee) }),
        gasLimit: (ffi.gas_limit).map({ ptr in ffiByteBufferToData(ptr.pointee) }),
        gasPrice: (ffi.gas_price).map({ ptr in ffiByteBufferToData(ptr.pointee) }),
        display: ffiByteBufferToString(ffi.display)
    )
}

/// Convert a C `FfiNativeRequest*` to a Swift `NativeRequest`, freeing the pointer.
private func convertNativeRequestPtr(_ ptr: UnsafeMutablePointer<FfiNativeRequest>) -> NativeRequest {
    let value = convertNativeRequest(ptr.pointee)
    zcash_eip681_free_native_request(ptr)
    return value
}

/// Convert a C `FfiErc20Request` to a Swift `Erc20Request`, freeing the C memory.
private func convertErc20Request(_ ffi: FfiErc20Request) -> Erc20Request {
    return Erc20Request(
        chainId: (ffi.chain_id).map({ ptr in ptr.pointee }),
        tokenContractAddress: ffiByteBufferToString(ffi.token_contract_address),
        recipientAddress: ffiByteBufferToString(ffi.recipient_address),
        valueAtomic: ffiByteBufferToData(ffi.value_atomic),
        display: ffiByteBufferToString(ffi.display)
    )
}

/// Convert a C `FfiErc20Request*` to a Swift `Erc20Request`, freeing the pointer.
private func convertErc20RequestPtr(_ ptr: UnsafeMutablePointer<FfiErc20Request>) -> Erc20Request {
    let value = convertErc20Request(ptr.pointee)
    zcash_eip681_free_erc20_request(ptr)
    return value
}

/// Convert a C `FfiTransactionRequest` to a Swift `TransactionRequest`.
private func convertTransactionRequest(_ ffi: FfiTransactionRequest) -> TransactionRequest {
    switch ffi.tag {
    case FFI_TRANSACTION_REQUEST_NATIVE:
        let payload = convertNativeRequest(ffi.native!.pointee.value)
        return .native(payload)
    case FFI_TRANSACTION_REQUEST_ERC20:
        let payload = convertErc20Request(ffi.erc20!.pointee.value)
        return .erc20(payload)
    case FFI_TRANSACTION_REQUEST_UNRECOGNISED:
        let payload = ffiByteBufferToString(ffi.unrecognised!.pointee.value)
        return .unrecognised(payload)
    default:
        fatalError("Unknown TransactionRequest tag: \(ffi.tag)")
    }
}

/// Convert a C `FfiTransactionRequest*` to a Swift `TransactionRequest`, freeing the pointer.
private func convertTransactionRequestPtr(_ ptr: UnsafeMutablePointer<FfiTransactionRequest>) -> TransactionRequest {
    let value = convertTransactionRequest(ptr.pointee)
    zcash_eip681_free_transaction_request(ptr)
    return value
}

// MARK: - Public API

/// Eip681 FFI bindings.
public enum Eip681 {

    /// Parse an EIP-681 URI string into a transaction request.
    ///
    /// Returns an error string if parsing fails.
    public static func parserParse(_ input: String) throws -> TransactionRequest {
        return try input.utf8CString.withUnsafeBufferPointer { inputBuf in
            let inputSlice = FfiByteSlice(ptr: UnsafeRawPointer(inputBuf.baseAddress!).assumingMemoryBound(to: UInt8.self), len: inputBuf.count - 1)
            let resultPtr = zcash_eip681_parser_parse(inputSlice)
            guard let resultPtr = resultPtr else {
                throw WitFFIError.readLastError()
            }
            return convertTransactionRequestPtr(resultPtr)
        }
    }
}
