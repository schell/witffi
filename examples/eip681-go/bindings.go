// Code generated by witffi. DO NOT EDIT.

package eip681

/*
#cgo LDFLAGS: -leip681_ffi
#include "witffi_types.h"
#include "ffi.h"
#include <stdlib.h>
*/
import "C"

import (
	"fmt"
	"unsafe"
)

// ---- Helpers ----

func ffiByteBufferToString(buf C.FfiByteBuffer) string {
	if buf.ptr == nil || buf.len == 0 {
		C.zcash_eip681_free_byte_buffer(buf)
		return ""
	}
	s := C.GoStringN((*C.char)(unsafe.Pointer(buf.ptr)), C.int(buf.len))
	C.zcash_eip681_free_byte_buffer(buf)
	return s
}

func ffiByteBufferToBytes(buf C.FfiByteBuffer) []byte {
	if buf.ptr == nil || buf.len == 0 {
		C.zcash_eip681_free_byte_buffer(buf)
		return nil
	}
	b := C.GoBytes(unsafe.Pointer(buf.ptr), C.int(buf.len))
	C.zcash_eip681_free_byte_buffer(buf)
	return b
}

func readLastError() string {
	length := C.zcash_eip681_last_error_length()
	if length <= 0 {
		return "unknown error"
	}
	buf := make([]byte, length)
	C.zcash_eip681_error_message_utf8((*C.char)(unsafe.Pointer(&buf[0])), length)
	return string(buf[:length-1])
}

// ---- Types ----

// A native ETH transfer request.
type NativeRequest struct {
	// The schema prefix (e.g. "ethereum").
	SchemaPrefix string
	// The chain ID, if specified.
	ChainId *uint64
	// The recipient address (ERC-55 checksummed hex string).
	RecipientAddress string
	// The value in atomic units (wei), if specified.
	ValueAtomic *[]byte
	// The gas limit, if specified.
	GasLimit *[]byte
	// The gas price, if specified.
	GasPrice *[]byte
	// The canonical display string (round-trips through parsing).
	Display string
}

// An ERC-20 token transfer request.
type Erc20Request struct {
	// The chain ID, if specified.
	ChainId *uint64
	// The token contract address (ERC-55 checksummed hex string).
	TokenContractAddress string
	// The recipient address.
	RecipientAddress string
	// The value in atomic token units.
	ValueAtomic []byte
	// The canonical display string.
	Display string
}

type transactionRequestVariant interface {
	isTransactionRequest()
}

// A parsed EIP-681 transaction request.
type TransactionRequest = transactionRequestVariant

// A native ETH transfer.
type TransactionRequestNative struct { Value NativeRequest }
func (TransactionRequestNative) isTransactionRequest() {}

// An ERC-20 token transfer.
type TransactionRequestErc20 struct { Value Erc20Request }
func (TransactionRequestErc20) isTransactionRequest() {}

// An unrecognised request (raw URI string preserved).
type TransactionRequestUnrecognised struct { Value string }
func (TransactionRequestUnrecognised) isTransactionRequest() {}

type U256 = []byte

// ---- Conversion Functions ----

func convertNativeRequest(ffi C.FfiNativeRequest) NativeRequest {
	result := NativeRequest{
		SchemaPrefix: ffiByteBufferToString(ffi.schema_prefix),
		RecipientAddress: ffiByteBufferToString(ffi.recipient_address),
		Display: ffiByteBufferToString(ffi.display),
	}
	if ffi.chain_id != nil {
		v := uint64(*ffi.chain_id)
		result.ChainId = &v
		C.free(unsafe.Pointer(ffi.chain_id))
	}
	if ffi.value_atomic != nil {
		v := ffiByteBufferToBytes(*ffi.value_atomic)
		result.ValueAtomic = v
		C.free(unsafe.Pointer(ffi.value_atomic))
	}
	if ffi.gas_limit != nil {
		v := ffiByteBufferToBytes(*ffi.gas_limit)
		result.GasLimit = v
		C.free(unsafe.Pointer(ffi.gas_limit))
	}
	if ffi.gas_price != nil {
		v := ffiByteBufferToBytes(*ffi.gas_price)
		result.GasPrice = v
		C.free(unsafe.Pointer(ffi.gas_price))
	}
	return result
}

func convertErc20Request(ffi C.FfiErc20Request) Erc20Request {
	result := Erc20Request{
		TokenContractAddress: ffiByteBufferToString(ffi.token_contract_address),
		RecipientAddress: ffiByteBufferToString(ffi.recipient_address),
		ValueAtomic: ffiByteBufferToBytes(ffi.value_atomic),
		Display: ffiByteBufferToString(ffi.display),
	}
	if ffi.chain_id != nil {
		v := uint64(*ffi.chain_id)
		result.ChainId = &v
		C.free(unsafe.Pointer(ffi.chain_id))
	}
	return result
}

func convertTransactionRequest(ffi C.FfiTransactionRequest) TransactionRequest {
	switch ffi.tag {
	case C.FFI_TRANSACTION_REQUEST_NATIVE:
		return TransactionRequestNative{Value: convertNativeRequest(ffi.native.value)}
	case C.FFI_TRANSACTION_REQUEST_ERC20:
		return TransactionRequestErc20{Value: convertErc20Request(ffi.erc20.value)}
	case C.FFI_TRANSACTION_REQUEST_UNRECOGNISED:
		return TransactionRequestUnrecognised{Value: ffiByteBufferToString(ffi.unrecognised.value)}
	default:
		panic(fmt.Sprintf("unknown TransactionRequest tag: %d", ffi.tag))
	}
}

// ---- Public API ----

// Parse an EIP-681 URI string into a transaction request.
//
// Returns an error string if parsing fails.
func ParserParse(input string) (TransactionRequest, error) {
	inputSlice := C.FfiByteSlice{
		ptr: (*C.uint8_t)(unsafe.Pointer(unsafe.StringData(input))),
		len: C.uintptr_t(len(input)),
	}
	resultPtr := C.zcash_eip681_parser_parse(inputSlice)
	if resultPtr == nil {
		return nil, fmt.Errorf("zcash_eip681_parser_parse failed: %s", readLastError())
	}
	result := convertTransactionRequest(*resultPtr)
	C.zcash_eip681_free_transaction_request(resultPtr)
	return result, nil
}

// Convert a u256 type to a string for display
func FunctionsU256ToString(input []byte) string {
	inputSlice := C.FfiByteSlice{
		ptr: (*C.uint8_t)(unsafe.Pointer(unsafe.SliceData(input))),
		len: C.uintptr_t(len(input)),
	}
	result := C.zcash_eip681_functions_u256_to_string(inputSlice)
	return ffiByteBufferToString(result)
}
