# Go Bindings Generator — Implementation Plan

**Date:** 2026-02-20
**Status:** Ready to implement — all design decisions made

## Summary

`witffi-go` generates a single `.go` file that calls the existing C-ABI functions
via CGo. This is the same strategy as the Swift generator: the Go code calls the
C functions directly, deep-copies all data into native Go types, and frees the C
memory immediately. No intermediate layer.

## Architecture Decision

**Go calls the existing C-ABI via CGo** (like Swift calls C directly).

Rationale:
- Go has first-class C interop via CGo — no extra dependencies needed
- Reuses the same C-ABI layer produced by `witffi-rust` (no new Rust code)
- Deep-copy + immediate free matches Go's garbage-collected memory model
- The generated `.go` file is self-contained (single file, no Go framework)

## Design Decisions

### Variant Representation

**Interface + concrete types** (most idiomatic Go):

```go
// Unexported marker interface
type transactionRequestVariant interface {
    isTransactionRequest()
}

// Concrete types implement the marker
type TransactionRequestNative struct { Value NativeRequest }
func (TransactionRequestNative) isTransactionRequest() {}

type TransactionRequestErc20 struct { Value Erc20Request }
func (TransactionRequestErc20) isTransactionRequest() {}

type TransactionRequestUnrecognised struct { Value string }
func (TransactionRequestUnrecognised) isTransactionRequest() {}

// Public type alias
type TransactionRequest = transactionRequestVariant
```

Consumers use type switches:

```go
switch v := result.(type) {
case TransactionRequestNative:
    fmt.Println(v.Value.RecipientAddress)
}
```

### Optional Types

**Pointer pattern** — `*uint64`, `*string`, etc. `nil` means absent.

For optional records/variants, use `*NativeRequest` (nil = absent).

### Error Handling

`result<T, E>` maps to Go's `(T, error)` multi-return idiom:
- On success: return the converted value and `nil` error
- On failure: call `readLastError()` to get the error string, return zero value
  and `fmt.Errorf(...)` (or a typed error wrapping the string)

### Package Name

Derived from the WIT world name (e.g., world `eip681` -> `package eip681`).
Override with `--go-package` CLI flag.

### CGo LDFLAGS

`GoConfig` has a `lib_name` field. Generated preamble includes:

```go
// #cgo LDFLAGS: -l${lib_name}
// #include "witffi_types.h"
// #include "ffi.h"
import "C"
```

### Memory Management

Same strategy as Swift — deep-copy everything, free immediately:

```go
func ffiByteBufferToString(buf C.FfiByteBuffer) string {
    if buf.data == nil || buf.len == 0 {
        C.witffi_free_byte_buffer(buf)
        return ""
    }
    s := C.GoStringN((*C.char)(unsafe.Pointer(buf.data)), C.int(buf.len))
    C.witffi_free_byte_buffer(buf)
    return s
}
```

## Type Mapping

| WIT Type | Go Type | C Type (CGo) | Direction |
|----------|---------|--------------|-----------|
| `string` (input) | `string` | `C.FfiByteSlice` | Go -> C |
| `string` (output) | `string` | `C.FfiByteBuffer` | C -> Go |
| `list<u8>` (input) | `[]byte` | `C.FfiByteSlice` | Go -> C |
| `list<u8>` (output) | `[]byte` | `C.FfiByteBuffer` | C -> Go |
| `bool` | `bool` | `C.bool` | both |
| `u8` | `uint8` | `C.uint8_t` | both |
| `u16` | `uint16` | `C.uint16_t` | both |
| `u32` | `uint32` | `C.uint32_t` | both |
| `u64` | `uint64` | `C.uint64_t` | both |
| `s8` | `int8` | `C.int8_t` | both |
| `s16` | `int16` | `C.int16_t` | both |
| `s32` | `int32` | `C.int32_t` | both |
| `s64` | `int64` | `C.int64_t` | both |
| `f32` | `float32` | `C.float` | both |
| `f64` | `float64` | `C.double` | both |
| `option<T>` (primitive) | `*T` | nullable `*C.T` | C -> Go |
| `option<T>` (record) | `*RecordType` | nullable `*C.FfiRecord` | C -> Go |
| record | Go struct | `C.FfiRecordName` | C -> Go |
| variant | interface + concrete types | `C.FfiVariantName` (tagged union) | C -> Go |
| enum | `type Foo uint32` + constants | `C.uint32_t` tag | C -> Go |
| `result<T, E>` | `(T, error)` return | success ptr or `last_error` | C -> Go |

## Implementation Steps

### Step 1: Add Go keyword escaping to `witffi-core`

**File:** `crates/witffi-core/src/names.rs`

Add `escape_go_keyword(name: &str) -> String`:
- Appends `_` to Go reserved words: `break`, `case`, `chan`, `const`,
  `continue`, `default`, `defer`, `else`, `fallthrough`, `for`, `func`, `go`,
  `goto`, `if`, `import`, `interface`, `map`, `package`, `range`, `return`,
  `select`, `struct`, `switch`, `type`, `var`
- Also escape Go predeclared identifiers that could collide: `len`, `cap`,
  `make`, `new`, `append`, `copy`, `delete`, `close`, `panic`, `recover`,
  `print`, `println`, `error`, `string`, `bool`, `int`, `uint`, `byte`, `rune`,
  `float32`, `float64`, `complex64`, `complex128`, `true`, `false`, `nil`,
  `iota`

Add `to_go_ident(name: &str) -> String` for unexported/local identifiers:
- `camelCase` conversion
- Calls `escape_go_keyword`

Update existing `to_go_type`, `to_go_func`, `to_go_field` to call
`escape_go_keyword` (PascalCase names are unlikely to collide with lowercase
reserved words, but it's defensive).

Add tests:
- `assert_eq!(to_go_ident("type"), "type_")`
- `assert_eq!(to_go_ident("chain-id"), "chainId")`
- `assert_eq!(to_go_type("transaction-request"), "TransactionRequest")`

### Step 2: Create `crates/witffi-go/` crate

#### `Cargo.toml`

```toml
[package]
name = "witffi-go"
version = "0.1.0"
edition.workspace = true

[dependencies]
witffi-core.workspace = true
wit-parser.workspace = true
snafu.workspace = true
heck.workspace = true

[dev-dependencies]
pretty_assertions.workspace = true
```

#### `src/lib.rs`

```rust
//! Go bindings code generator for WIT interfaces.

pub mod generate;

pub use generate::GoGenerator;
```

#### `src/generate.rs` — Structure

The file follows the same pattern as `crates/witffi-swift/src/generate.rs`:

```rust
//! Go bindings code generator.
//!
//! Walks the resolved WIT types and produces a single `.go` file containing:
//! 1. CGo preamble with LDFLAGS and #include directives
//! 2. Helper functions for FfiByteBuffer/FfiByteSlice marshalling
//! 3. Go structs for WIT records
//! 4. Go interfaces + concrete types for WIT variants
//! 5. Go typed constants for WIT enums
//! 6. Conversion functions (C struct -> Go type)
//! 7. Public API functions that call the C-ABI layer

pub struct GoConfig {
    pub c_prefix: String,       // e.g. "zcash_eip681"
    pub c_type_prefix: String,  // e.g. "Ffi"
    pub go_package: Option<String>, // Override package name (default: world name)
    pub lib_name: String,       // Library name for LDFLAGS (e.g. "eip681_ffi")
}

pub struct GoGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: GoConfig,
}
```

### Step 3: Generator sections (output order)

The `generate_inner(&self, out: &mut String) -> fmt::Result` method calls these
private methods in order:

#### 3a. `generate_header(out)` — File header + package declaration

```go
// Code generated by witffi. DO NOT EDIT.

package eip681
```

#### 3b. `generate_cgo_preamble(out)` — CGo directives

```go
/*
#cgo LDFLAGS: -leip681_ffi
#include "witffi_types.h"
#include "ffi.h"
#include <stdlib.h>
*/
import "C"
```

Note: The `import "C"` line MUST immediately follow the closing `*/` with no
blank line between them (CGo requirement).

#### 3c. `generate_imports(out)` — Go imports

```go
import (
    "fmt"
    "unsafe"
)
```

Only emit imports that are actually used. `unsafe` is always needed for CGo
pointer operations. `fmt` is needed if any `result<T, E>` functions exist (for
`fmt.Errorf`).

#### 3d. `generate_helpers(out)` — Internal helper functions

- `ffiByteBufferToString(buf C.FfiByteBuffer) string` — copies via
  `C.GoStringN`, then calls the free function
- `ffiByteBufferToBytes(buf C.FfiByteBuffer) []byte` — copies via `C.GoBytes`,
  then calls the free function
- `readLastError() string` — calls `{c_prefix}_last_error()`, returns the error
  string (or a fallback message)

Free function name: `{c_prefix}_free_byte_buffer` (matching the Rust-generated
C-ABI).

#### 3e. `generate_types(out)` — Go type definitions

Walk reachable types in dependency order (same `collect_reachable_types` logic as
Swift generator).

For each `TypeDefKind`:

- **Record** -> Go struct with PascalCase fields:
  ```go
  // NativeRequest represents a native Ethereum transaction request.
  type NativeRequest struct {
      SchemaPrefix     string
      ChainId          *uint64
      RecipientAddress string
      ValueAtomic      []byte
      GasLimit         []byte
      GasPrice         []byte
      Display          string
  }
  ```

- **Variant** -> Unexported marker interface + exported concrete types:
  ```go
  type transactionRequestVariant interface {
      isTransactionRequest()
  }

  type TransactionRequest = transactionRequestVariant

  type TransactionRequestNative struct { Value NativeRequest }
  func (TransactionRequestNative) isTransactionRequest() {}

  type TransactionRequestErc20 struct { Value Erc20Request }
  func (TransactionRequestErc20) isTransactionRequest() {}

  type TransactionRequestUnrecognised struct { Value string }
  func (TransactionRequestUnrecognised) isTransactionRequest() {}
  ```

- **Enum** -> Typed uint32 + iota constants:
  ```go
  type Color uint32

  const (
      ColorRed   Color = iota
      ColorGreen
      ColorBlue
  )
  ```

- **Flags** -> Typed uint32 + bit-shifted constants:
  ```go
  type Permissions uint32

  const (
      PermissionsRead    Permissions = 1 << iota
      PermissionsWrite
      PermissionsExecute
  )
  ```

- **Type alias** (`list<u8>` aliased as `u256`) -> `type U256 = []byte`

#### 3f. `generate_conversion_functions(out)` — C-to-Go converters

One function per record and variant type:

```go
func convertNativeRequest(ffi C.FfiNativeRequest) NativeRequest {
    result := NativeRequest{
        SchemaPrefix:     ffiByteBufferToString(ffi.schema_prefix),
        RecipientAddress: ffiByteBufferToString(ffi.recipient_address),
        Display:          ffiByteBufferToString(ffi.display),
    }
    if ffi.chain_id != nil {
        v := uint64(*ffi.chain_id)
        result.ChainId = &v
        C.free(unsafe.Pointer(ffi.chain_id))
    }
    if ffi.value_atomic != nil {
        result.ValueAtomic = ffiByteBufferToBytes(*ffi.value_atomic)
        C.free(unsafe.Pointer(ffi.value_atomic))
    }
    // ... similar for other optional fields
    return result
}
```

For variants, switch on the tag field:

```go
func convertTransactionRequest(ffi C.FfiTransactionRequest) TransactionRequest {
    switch ffi.tag {
    case 0: // native
        payload := *(*C.FfiNativeRequest)(unsafe.Pointer(&ffi.payload))
        return TransactionRequestNative{Value: convertNativeRequest(payload)}
    case 1: // erc20
        payload := *(*C.FfiErc20Request)(unsafe.Pointer(&ffi.payload))
        return TransactionRequestErc20{Value: convertErc20Request(payload)}
    case 2: // unrecognised
        payload := *(*C.FfiByteBuffer)(unsafe.Pointer(&ffi.payload))
        return TransactionRequestUnrecognised{Value: ffiByteBufferToString(payload)}
    default:
        panic(fmt.Sprintf("unknown TransactionRequest tag: %d", ffi.tag))
    }
}
```

#### 3g. `generate_api(out)` — Public API functions

One function per exported WIT function:

```go
// Parse parses an EIP-681 URI string into a TransactionRequest.
func Parse(input string) (TransactionRequest, error) {
    inputSlice := C.FfiByteSlice{
        data: (*C.uint8_t)(unsafe.Pointer(unsafe.StringData(input))),
        len:  C.uintptr_t(len(input)),
    }
    resultPtr := C.zcash_eip681_parse(inputSlice)
    if resultPtr == nil {
        return nil, fmt.Errorf("parse failed: %s", readLastError())
    }
    result := convertTransactionRequest(*resultPtr)
    C.free(unsafe.Pointer(resultPtr))
    return result, nil
}
```

Key details for the API function generation:
- **String input params:** Create `C.FfiByteSlice` from Go string using
  `unsafe.StringData` (Go 1.20+) — avoids allocation
- **Byte slice input params:** Create `C.FfiByteSlice` from `[]byte` using
  `unsafe.SliceData`
- **Result types:** Check for null pointer, call `readLastError()` on failure
- **Non-result returns:** Directly convert via the appropriate conversion function
- **Void functions:** Just call the C function, no return conversion

### Step 4: Add `witffi-go` to workspace

**File:** `Cargo.toml` (root)

- Add `"crates/witffi-go"` to `members` list
- Add `witffi-go = { path = "crates/witffi-go" }` to `[workspace.dependencies]`

### Step 5: CLI integration

**File:** `crates/witffi-cli/src/main.rs`

- Add `Go` variant to `Language` enum
- Add optional CLI args: `--go-package` (String), `--lib-name` (String, default
  derived from `c_prefix`)
- Add `Cargo.toml` dependency on `witffi-go`
- Add dispatch arm:
  ```rust
  Language::Go => {
      let config = GoConfig {
          c_prefix: c_prefix.clone(),
          c_type_prefix: c_type_prefix.clone(),
          go_package: go_package.clone(),
          lib_name: lib_name.unwrap_or_else(|| /* derive from c_prefix */),
      };
      let generator = GoGenerator::new(&resolve, world_id, config);
      let code = generator.generate().whatever_context("Go generation failed")?;
      std::fs::write(output.join("bindings.go"), &code)
          .whatever_context("failed to write bindings.go")?;
  }
  ```

### Step 6: Tests

**File:** `crates/witffi-go/src/generate.rs` (bottom of file)

#### `test_generate_go_from_eip681`

Load `wit/eip681.wit`, generate Go code, assert it contains expected sections:
- `package eip681`
- `#cgo LDFLAGS`
- `import "C"`
- `type NativeRequest struct`
- `type Erc20Request struct`
- `type transactionRequestVariant interface`
- `type TransactionRequestNative struct`
- `func convertNativeRequest`
- `func convertTransactionRequest`
- `func Parse(input string) (TransactionRequest, error)`

Also `eprintln!` the full output for manual inspection during development.

#### `test_go_type_mapping`

Unit test for the `type_to_go` helper function (if extracted as a standalone
method):
- `string` -> `string`
- `bool` -> `bool`
- `u64` -> `uint64`
- `s32` -> `int32`
- `f64` -> `float64`
- `list<u8>` -> `[]byte`
- `option<u64>` -> `*uint64`

#### `test_go_package_name_derivation`

Verify that the world name `eip681` produces `package eip681`, and that a
`go_package` override of `"mypkg"` produces `package mypkg`.

### Step 7: Verification

```sh
cargo fmt --all
cargo clippy --workspace
cargo test --workspace
```

All existing 21 tests must continue to pass. The new Go generator should add at
least 3 more tests.

## Generated Output Preview (eip681)

The complete expected output for `wit/eip681.wit` with config
`{ c_prefix: "zcash_eip681", c_type_prefix: "Ffi", lib_name: "eip681_ffi" }`:

```go
// Code generated by witffi. DO NOT EDIT.

package eip681

/*
#cgo LDFLAGS: -leip681_ffi
#include "witffi_types.h"
#include "ffi.h"
#include <stdlib.h>
*/
import "C"

import (
	"fmt"
	"unsafe"
)

// ---- Helpers ----

func ffiByteBufferToString(buf C.FfiByteBuffer) string {
	if buf.data == nil || buf.len == 0 {
		C.zcash_eip681_free_byte_buffer(buf)
		return ""
	}
	s := C.GoStringN((*C.char)(unsafe.Pointer(buf.data)), C.int(buf.len))
	C.zcash_eip681_free_byte_buffer(buf)
	return s
}

func ffiByteBufferToBytes(buf C.FfiByteBuffer) []byte {
	if buf.data == nil || buf.len == 0 {
		C.zcash_eip681_free_byte_buffer(buf)
		return nil
	}
	b := C.GoBytes(unsafe.Pointer(buf.data), C.int(buf.len))
	C.zcash_eip681_free_byte_buffer(buf)
	return b
}

func readLastError() string {
	buf := C.zcash_eip681_last_error()
	if buf.data == nil || buf.len == 0 {
		return "unknown error"
	}
	return ffiByteBufferToString(buf)
}

// ---- Types ----

// NativeRequest represents a native Ethereum transaction request.
type NativeRequest struct {
	SchemaPrefix     string
	ChainId          *uint64
	RecipientAddress string
	ValueAtomic      []byte
	GasLimit         []byte
	GasPrice         []byte
	Display          string
}

// Erc20Request represents an ERC-20 token transfer request.
type Erc20Request struct {
	ChainId              *uint64
	TokenContractAddress string
	RecipientAddress     string
	ValueAtomic          []byte
	Display              string
}

type transactionRequestVariant interface {
	isTransactionRequest()
}

// TransactionRequest is a parsed EIP-681 transaction request.
type TransactionRequest = transactionRequestVariant

// TransactionRequestNative holds a native ETH transfer request.
type TransactionRequestNative struct {
	Value NativeRequest
}

func (TransactionRequestNative) isTransactionRequest() {}

// TransactionRequestErc20 holds an ERC-20 token transfer request.
type TransactionRequestErc20 struct {
	Value Erc20Request
}

func (TransactionRequestErc20) isTransactionRequest() {}

// TransactionRequestUnrecognised holds an unrecognised transaction request URI.
type TransactionRequestUnrecognised struct {
	Value string
}

func (TransactionRequestUnrecognised) isTransactionRequest() {}

// ---- Conversion Functions ----

func convertNativeRequest(ffi C.FfiNativeRequest) NativeRequest {
	result := NativeRequest{
		SchemaPrefix:     ffiByteBufferToString(ffi.schema_prefix),
		RecipientAddress: ffiByteBufferToString(ffi.recipient_address),
		Display:          ffiByteBufferToString(ffi.display),
	}
	if ffi.chain_id != nil {
		v := uint64(*ffi.chain_id)
		result.ChainId = &v
		C.free(unsafe.Pointer(ffi.chain_id))
	}
	if ffi.value_atomic != nil {
		result.ValueAtomic = ffiByteBufferToBytes(*ffi.value_atomic)
		C.free(unsafe.Pointer(ffi.value_atomic))
	}
	if ffi.gas_limit != nil {
		result.GasLimit = ffiByteBufferToBytes(*ffi.gas_limit)
		C.free(unsafe.Pointer(ffi.gas_limit))
	}
	if ffi.gas_price != nil {
		result.GasPrice = ffiByteBufferToBytes(*ffi.gas_price)
		C.free(unsafe.Pointer(ffi.gas_price))
	}
	return result
}

func convertErc20Request(ffi C.FfiErc20Request) Erc20Request {
	result := Erc20Request{
		TokenContractAddress: ffiByteBufferToString(ffi.token_contract_address),
		RecipientAddress:     ffiByteBufferToString(ffi.recipient_address),
		ValueAtomic:          ffiByteBufferToBytes(ffi.value_atomic),
		Display:              ffiByteBufferToString(ffi.display),
	}
	if ffi.chain_id != nil {
		v := uint64(*ffi.chain_id)
		result.ChainId = &v
		C.free(unsafe.Pointer(ffi.chain_id))
	}
	return result
}

func convertTransactionRequest(ffi C.FfiTransactionRequest) TransactionRequest {
	switch ffi.tag {
	case 0:
		payload := *(*C.FfiNativeRequest)(unsafe.Pointer(&ffi.payload))
		return TransactionRequestNative{Value: convertNativeRequest(payload)}
	case 1:
		payload := *(*C.FfiErc20Request)(unsafe.Pointer(&ffi.payload))
		return TransactionRequestErc20{Value: convertErc20Request(payload)}
	case 2:
		payload := *(*C.FfiByteBuffer)(unsafe.Pointer(&ffi.payload))
		return TransactionRequestUnrecognised{Value: ffiByteBufferToString(payload)}
	default:
		panic(fmt.Sprintf("unknown TransactionRequest tag: %d", ffi.tag))
	}
}

// ---- Public API ----

// Parse parses an EIP-681 URI string into a TransactionRequest.
func Parse(input string) (TransactionRequest, error) {
	inputSlice := C.FfiByteSlice{
		data: (*C.uint8_t)(unsafe.Pointer(unsafe.StringData(input))),
		len:  C.uintptr_t(len(input)),
	}
	resultPtr := C.zcash_eip681_parse(inputSlice)
	if resultPtr == nil {
		return nil, fmt.Errorf("parse failed: %s", readLastError())
	}
	result := convertTransactionRequest(*resultPtr)
	C.free(unsafe.Pointer(resultPtr))
	return result, nil
}
```

## Open Considerations

### CGo and `unsafe.StringData`

`unsafe.StringData` was added in Go 1.20. If we need to support Go < 1.20, the
alternative is:

```go
cs := C.CString(input)
defer C.free(unsafe.Pointer(cs))
```

This allocates + copies, but is universally compatible. For now, we target
Go 1.20+ since it's been stable for over 2 years.

### Variant Payload Alignment

The C-side variant struct has a `payload` field that is a `union`. CGo doesn't
directly support C unions, so the payload is accessed via unsafe pointer casts:

```go
payload := *(*C.FfiNativeRequest)(unsafe.Pointer(&ffi.payload))
```

This works because CGo represents the union as a byte array sized to the largest
variant. The pointer cast reinterprets the bytes. This is safe as long as the tag
matches — which the switch statement guarantees.

### Optional Pointer Freeing

When the C-ABI returns `option<T>` as a nullable pointer (`*C.uint64_t`), the Go
side must:
1. Check for nil
2. Copy the value (`uint64(*ptr)`)
3. Free the pointer (`C.free(unsafe.Pointer(ptr))`)

This must happen for every optional field in every record conversion function.

### `eip681-go` Example (future)

After the generator is working, create `examples/eip681-go/`:

```
examples/eip681-go/
  go.mod
  eip681.go          # Generated bindings (committed)
  eip681_test.go     # Go tests
  build.sh           # cargo build + witffi generate + go test
```

This is a follow-up task, not part of the initial generator implementation.
