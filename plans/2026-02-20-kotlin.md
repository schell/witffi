# Kotlin/Android Bindings Generator — Plan

**Date:** 2026-02-20
**Status:** Ready to implement
**Architecture:** Direct JNI (confirmed by str4d from the zcash Android team)

## Decision Summary

- **JNI over JNA/JNR/Panama:** JNA has 10-20x call overhead. JNR is
  fundamentally broken on Android (dynamic bytecode class loading is
  unsupported by ART; 10 years of unresolved issues). Project Panama requires
  Java 22+ which Android doesn't support. Direct JNI is the only viable
  high-performance option.
- **Unified trait + dual registration macros:** `witffi-rust` generates a
  single `ffi.rs` containing idiomatic Rust types, one trait, and two macros:
  `witffi_register_ffi!` (C-ABI for Swift/Go) and `witffi_register_jni!`
  (JNI for Kotlin/Android). The consumer has one Rust FFI crate and invokes
  whichever macro(s) they need.
- **`witffi-kotlin` only generates Kotlin** (`Bindings.kt`). No Rust output.
  The Rust JNI bridge lives inside `witffi_register_jni!` in `ffi.rs`.
- **Boxed nullable types** for `option<primitive>` (e.g. `Long?` not sentinel
  `-1L`). Correct for all values, no domain loss.
- **Single file output** for each language, matching the Rust and Swift
  generator patterns.

### Rationale (from zcash team)

> It was a deliberate decision to use JNI, for two reasons: better type safety
> across the FFI using the jni crate, and better error handling.
>
> (we can throw exceptions directly with JNI, vs for C FFIs like we use in
> Swift the error handling is ugly)
>
> — str4d

## Architecture

### Unified Trait + Dual Registration Macros

The key architectural insight: the **trait always uses idiomatic Rust types**.
The registration macros handle all conversion — to `#[repr(C)]` structs for
C-ABI targets, or to JVM objects for JNI targets. This means:

- **One Rust FFI crate** (e.g. `eip681-ffi`) — the consumer never needs more
  than one
- **One generated Rust file** (`ffi.rs`, from `--lang rust`) — contains
  everything
- **Consumer code is platform-agnostic** — the same trait impl works for both
  Swift and Kotlin targets
- **No Rust code generation from `witffi-kotlin`** — it only produces
  `Bindings.kt`

### What `witffi-rust` generates (`ffi.rs`)

```rust
// ---- Idiomatic Rust Types (always generated) ----
pub struct NativeRequest {
    pub schema_prefix: String,
    pub chain_id: Option<u64>,
    pub recipient_address: String,
    // ...
}

pub enum TransactionRequest {
    Native(NativeRequest),
    Erc20(Erc20Request),
    Unrecognised(String),
}

// ---- Trait (always idiomatic Rust types) ----
pub trait Eip681 {
    fn parser_parse(input: &str) -> Result<TransactionRequest, String>;
}

// ---- C-ABI Registration Macro ----
macro_rules! witffi_register_ffi {
    ($impl_type:ty) => {
        // Generates: #[repr(C)] shadow types, conversion from
        // idiomatic -> repr(C), extern "C" functions, last_error
        // pattern, free functions
    };
}

// ---- JNI Registration Macro ----
macro_rules! witffi_register_jni {
    ($impl_type:ty) => {
        // Generates: Java_ entry points, env.new_object()
        // conversions, catch_unwind + throw_new error handling
    };
}
```

### What the consumer writes

```rust
// eip681-ffi/src/lib.rs
mod ffi;
use ffi::*;

struct Impl;

impl Eip681 for Impl {
    fn parser_parse(input: &str) -> Result<TransactionRequest, String> {
        let parsed = eip681::parse(input)?;
        Ok(TransactionRequest::Native(NativeRequest {
            schema_prefix: parsed.schema_prefix,
            chain_id: parsed.chain_id,
            // ...
        }))
    }
}

// Pick one or both:
witffi_register_ffi!(Impl);   // C-ABI extern "C" functions for Swift/Go
witffi_register_jni!(Impl);   // Java_ JNI functions for Kotlin/Android
```

### What `witffi-kotlin` generates (`Bindings.kt`)

- **Kotlin side only:** `@Keep` model classes (sealed classes for variants,
  regular classes for records), `external fun` declarations in a companion
  object, `System.loadLibrary()` loader, interface for the public API
  contract.

### Generation commands

```sh
# Generates ffi.rs (types + trait + both macros) + ffi.h + witffi_types.h
witffi generate --wit eip681.wit --lang rust --output out/

# Generates Bindings.kt only (no Rust output)
witffi generate --wit eip681.wit --lang kotlin --output out/
```

### Pros

- Zero extra dependencies on Android (JNI is built into Android NDK)
- Constructs rich Kotlin types directly (sealed classes, nullable fields)
- No double-marshaling — both macros convert directly from idiomatic Rust
- Consumer writes one Rust FFI crate, one trait impl, platform-agnostic code
- Both macros can coexist — different symbol names, no conflicts
- Matches the pattern the zcash SDK already uses

### Cons

- `witffi_register_jni!` must know JVM class paths (tight coupling, but
  acceptable since it's auto-generated)
- The `witffi_register_ffi!` macro is more complex than before — it now
  generates `#[repr(C)]` shadow types and conversion logic internally,
  instead of relying on the consumer to do the conversion
- The `jni` crate becomes a dependency of the FFI crate (only needed when
  `witffi_register_jni!` is invoked; could be gated behind a cargo feature)

### Refactor implications for `witffi-rust`

This is a significant change to `witffi-rust`:

| Current | New |
|---------|-----|
| Trait returns `FfiTransactionRequest` (repr(C)) | Trait returns `TransactionRequest` (idiomatic Rust) |
| `#[repr(C)]` types are top-level in generated code | `#[repr(C)]` types move inside `witffi_register_ffi!` |
| `witffi_register!` generates extern "C" wrappers only | `witffi_register_ffi!` generates repr(C) types + conversion + extern "C" wrappers |
| Consumer manually converts domain types -> FFI types | Consumer works with idiomatic Rust types; macro handles conversion |
| No JNI support | `witffi_register_jni!` generates JNI bridge |

The existing `witffi_register!` macro name can be kept as an alias for
`witffi_register_ffi!` for backward compatibility, or renamed outright.

## Implementation Phases

### Phase 1: Core Infrastructure (witffi-core changes)

Add Kotlin name conversion functions to `crates/witffi-core/src/names.rs`:

- `to_kotlin_type(name: &str) -> String` — PascalCase via `heck` (identical
  to `to_swift_type`)
- `to_kotlin_ident(name: &str) -> String` — camelCase via `heck` + keyword
  escaping
- `escape_kotlin_keyword(name: &str) -> String` — backtick-wrap for Kotlin
  keywords: `when`, `fun`, `val`, `var`, `is`, `in`, `object`, `typealias`,
  `data`, `sealed`, `companion`, `by`, `inner`, `out`, `it`, `as`, `class`,
  `interface`, `package`, `return`, `throw`, `try`, `catch`, `finally`, `for`,
  `while`, `do`, `if`, `else`, `super`, `this`, `true`, `false`, `null`
- Tests for all three functions

### Phase 2: Refactor `witffi-rust` — Unified Trait + Dual Macros

This is the most significant phase. The current `witffi-rust` generator must
be refactored so the trait uses idiomatic Rust types, and all FFI conversion
moves into the registration macros.

#### 2.1 New generated type definitions (idiomatic Rust)

Replace the current top-level `#[repr(C)]` types with idiomatic Rust types:

```rust
pub struct NativeRequest {
    pub schema_prefix: String,
    pub chain_id: Option<u64>,
    pub recipient_address: String,
    pub value_atomic: Option<Vec<u8>>,
    // ...
}

pub enum TransactionRequest {
    Native(NativeRequest),
    Erc20(Erc20Request),
    Unrecognised(String),
}
```

#### 2.2 New trait (idiomatic return types)

```rust
pub trait Eip681 {
    fn parser_parse(input: &str) -> Result<TransactionRequest, String>;
}
```

#### 2.3 `witffi_register_ffi!` macro

Replaces the current `witffi_register!`. Internally generates:
- `#[repr(C)]` shadow types (`FfiNativeRequest`, `FfiTransactionRequest`, etc.)
- Conversion functions from idiomatic -> repr(C) types
- `extern "C"` entry points
- `last_error` thread-local pattern
- Free functions for heap-allocated types

The consumer no longer writes manual conversion code — the macro does it.

#### 2.4 `witffi_register_jni!` macro

New macro. Internally generates:
- `Java_` JNI entry points (`#[unsafe(no_mangle)] pub extern "C" fn Java_...`)
- `to_jni_*` conversion helpers (`env.new_object()` calls)
- `catch_unwind` + `env.throw_new()` error handling
- JNI type descriptor strings

Requires the `jni` crate as a dependency of the FFI crate. This can be gated
behind a cargo feature (e.g. `features = ["jni"]`).

#### 2.5 Backward compatibility

- Rename `witffi_register!` to `witffi_register_ffi!`
- Optionally keep `witffi_register!` as a deprecated alias

### Phase 3: Create `witffi-kotlin` Crate (Kotlin output only)

#### 3.1 Crate layout

```
crates/witffi-kotlin/
  Cargo.toml       # witffi-core, wit-parser, snafu, heck
  src/
    lib.rs         # pub use generate::KotlinGenerator;
    generate.rs    # ~800 lines (Kotlin only, no Rust output)
```

#### 3.2 Config and generator structs

```rust
pub struct KotlinConfig {
    pub c_prefix: String,               // e.g. "zcash_eip681"
    pub kotlin_package: Option<String>, // override, else derived from WIT
    pub lib_name: String,               // for System.loadLibrary(...)
}

pub struct KotlinGenerator<'a> {
    resolve: &'a Resolve,
    world_id: WorldId,
    config: KotlinConfig,
}
```

#### 3.3 Public API

```rust
pub fn new(resolve, world_id, config) -> Self
pub fn generate(&self) -> Result<String, Error>    // Bindings.kt only
```

Delegates to `generate_inner` via `.context(WriteSnafu)?`.

#### 3.4 Error type

```rust
#[derive(Debug, Snafu)]
pub enum Error {
    #[snafu(display("code generation write error"))]
    Write { source: std::fmt::Error },
}
```

### Phase 3: Kotlin Code Generation (`generate_kotlin`)

#### 3.1 Package & imports

```kotlin
package zcash.eip681

import androidx.annotation.Keep
```

Package derived from WIT package name (`zcash:eip681` -> `zcash.eip681`),
overridable via `kotlin_package`.

#### 3.2 Records

```kotlin
@Keep
class NativeRequest(
    val schemaPrefix: String,
    val chainId: Long?,              // option<u64> -> boxed Long?
    val recipientAddress: String,
    val valueAtomic: ByteArray?,     // option<list<u8>> -> ByteArray?
    val gasLimit: ByteArray?,
    val gasPrice: ByteArray?,
    val display: String,
)
```

#### 3.3 Variants (sealed class hierarchy)

```kotlin
@Keep
sealed class TransactionRequest {
    @Keep class Native(val value: NativeRequest) : TransactionRequest()
    @Keep class Erc20(val value: Erc20Request) : TransactionRequest()
    @Keep class Unrecognised(val value: String) : TransactionRequest()
}
```

#### 3.4 Enums

```kotlin
enum class Color(val value: Long) {
    RED(0), GREEN(1), BLUE(2);
    companion object {
        fun fromValue(v: Long) = entries.first { it.value == v }
    }
}
```

#### 3.5 Flags

```kotlin
@JvmInline
value class Permissions(val rawValue: Long) {
    companion object {
        val READ = Permissions(1L shl 0)
        val WRITE = Permissions(1L shl 1)
    }
    operator fun plus(other: Permissions) = Permissions(rawValue or other.rawValue)
    fun contains(flag: Permissions) = rawValue and flag.rawValue == flag.rawValue
}
```

#### 3.6 Type aliases

```kotlin
typealias U256 = ByteArray
```

#### 3.7 Backend interface

```kotlin
interface Eip681Backend {
    fun parserParse(input: String): TransactionRequest   // throws on error
}
```

#### 3.8 Implementation class

```kotlin
class Eip681(libraryName: String = "eip681") : Eip681Backend {
    companion object {
        private var loaded = false
        @Synchronized
        fun loadLibrary(name: String) {
            if (!loaded) {
                System.loadLibrary(name)
                loaded = true
            }
        }

        @JvmStatic private external fun nativeParserParse(input: String): TransactionRequest
    }

    init { loadLibrary(libraryName) }

    override fun parserParse(input: String): TransactionRequest {
        return nativeParserParse(input)
    }
}
```

### Phase 4: `witffi_register_jni!` Details

The `witffi_register_jni!` macro is generated inside `ffi.rs` by
`witffi-rust`. It contains all JNI-specific logic.

#### 4.1 JNI imports (generated inside the macro)

```rust
use jni::JNIEnv;
use jni::objects::{JClass, JObject, JString, JByteArray, JValue};
use jni::sys::{jstring, jobject, jlong, jint, jboolean, jbyteArray};
```

#### 4.2 JVM object construction helpers (inside macro)

Generated per type:

```rust
fn to_jni_native_request<'local>(
    env: &mut JNIEnv<'local>,
    value: &NativeRequest,
) -> jni::errors::Result<JObject<'local>> {
    let schema_prefix = env.new_string(&value.schema_prefix)?;
    let chain_id = match value.chain_id {
        Some(v) => env.new_object("java/lang/Long", "(J)V",
            &[JValue::Long(v as i64)])?,
        None => JObject::null(),
    };
    // ...
    env.new_object(
        "zcash/eip681/NativeRequest",
        "(Ljava/lang/String;Ljava/lang/Long;...)V",
        &[schema_prefix.into(), chain_id.into(), ...],
    )
}
```

#### 4.3 JNI entry points (inside macro)

```rust
#[unsafe(no_mangle)]
pub extern "C" fn Java_zcash_eip681_Eip681_00024Companion_nativeParserParse<'local>(
    mut env: JNIEnv<'local>,
    _class: JClass<'local>,
    input: JString<'local>,
) -> jobject {
    let result = std::panic::catch_unwind(
        std::panic::AssertUnwindSafe(|| {
            let input: String = env.get_string(&input)
                .map_err(|e| e.to_string())?
                .into();
            <$impl_type>::parser_parse(&input)
        })
    );
    match result {
        Ok(Ok(value)) => {
            match to_jni_transaction_request(&mut env, &value) {
                Ok(obj) => obj.into_raw(),
                Err(e) => {
                    let _ = env.throw_new(
                        "java/lang/RuntimeException",
                        format!("{e}"),
                    );
                    std::ptr::null_mut()
                }
            }
        }
        Ok(Err(e)) => {
            let _ = env.throw_new("java/lang/RuntimeException", &e);
            std::ptr::null_mut()
        }
        Err(_panic) => {
            let _ = env.throw_new(
                "java/lang/RuntimeException",
                "Rust panic",
            );
            std::ptr::null_mut()
        }
    }
}
```

#### 4.4 JNI function naming

The JNI spec encodes the fully-qualified class path:
- `zcash.eip681.Eip681.Companion.nativeParserParse` ->
  `Java_zcash_eip681_Eip681_00024Companion_nativeParserParse`
- `$` in inner class names is encoded as `_00024`

#### 4.5 JNI descriptor string generation

The generator must produce correct JNI type descriptors for
`env.new_object()` calls:

| Kotlin Type | JNI Descriptor |
|-------------|----------------|
| `Boolean` | `Z` |
| `Byte` | `B` |
| `Short` | `S` |
| `Int` | `I` |
| `Long` | `J` |
| `Float` | `F` |
| `Double` | `D` |
| `Char` | `C` |
| `String` | `Ljava/lang/String;` |
| `ByteArray` | `[B` |
| `Array<T>` | `[L{class};` |
| `Long?` (boxed) | `Ljava/lang/Long;` |
| `Int?` (boxed) | `Ljava/lang/Integer;` |
| Record | `L{package/path/Name};` |
| Variant | `L{package/path/Name};` |
| Variant case | `L{package/path/Name}${CaseName};` |
| Method sig | `({param descriptors}){return descriptor}` |

### Phase 5: CLI Integration

#### 5.1 Language enum

Add `Kotlin` variant to `Language` in `crates/witffi-cli/src/main.rs`.

#### 5.2 CLI arguments

Add optional args:
- `--kotlin-package` — override derived package name
- `--lib-name` — for `System.loadLibrary()`, defaults to a name derived
  from `c_prefix`

#### 5.3 Dispatch logic

`--lang rust` generates `ffi.rs` (always includes both macros), `ffi.h`, and
`witffi_types.h`.

`--lang kotlin` generates `Bindings.kt` only (no Rust output — the consumer
already has `ffi.rs` from the `--lang rust` step).

`--lang swift` generates `Bindings.swift` and `module.modulemap` (unchanged).

### Phase 6: Testing

#### 6.1 `witffi-rust` tests

- Test idiomatic Rust type generation (records, variants, enums, flags)
- Test trait generation with idiomatic return types
- Test `witffi_register_ffi!` macro output (repr(C) shadow types, extern "C"
  functions, conversions)
- Test `witffi_register_jni!` macro output (Java_ functions, env.new_object()
  calls, JNI descriptors)
- Ensure existing tests still pass after the refactor

#### 6.2 `witffi-kotlin` tests

- Test Kotlin model class generation (records, variants, enums, flags)
- Test `external fun` declaration generation
- Test type mapping for all WIT types
- Test package name derivation
- Test keyword escaping

#### 6.3 Assertions

Check that generated code contains expected strings (same pattern as existing
tests).

### Phase 7: Example

Update `examples/eip681-ffi/` to demonstrate both macros:

```rust
// examples/eip681-ffi/src/lib.rs
mod ffi;
use ffi::*;

struct Impl;
impl Eip681 for Impl { /* ... */ }

witffi_register_ffi!(Impl);   // C-ABI for Swift
witffi_register_jni!(Impl);   // JNI for Kotlin
```

Add `examples/eip681-kotlin/` with:
- The generated `Bindings.kt`
- Usage example showing Kotlin calling through to Rust via JNI
- Build instructions (cargo + gradle)

## Full WIT Type -> Kotlin Type Mapping

| WIT Type | Kotlin Type | JNI Descriptor | Rust JNI Handling |
|----------|-------------|----------------|-------------------|
| `bool` | `Boolean` | `Z` | `jboolean` |
| `u8` | `Byte` | `B` | `jbyte` (cast) |
| `u16` | `Short` | `S` | `jshort` (cast) |
| `u32` | `Int` | `I` | `jint` (cast) |
| `u64` | `Long` | `J` | `jlong` (cast) |
| `s8` | `Byte` | `B` | `jbyte` |
| `s16` | `Short` | `S` | `jshort` |
| `s32` | `Int` | `I` | `jint` |
| `s64` | `Long` | `J` | `jlong` |
| `f32` | `Float` | `F` | `jfloat` |
| `f64` | `Double` | `D` | `jdouble` |
| `char` | `Char` | `C` | `jchar` |
| `string` | `String` | `Ljava/lang/String;` | `JString<'local>` |
| `string` (return) | `String` | `Ljava/lang/String;` | `env.new_string()` |
| `list<u8>` | `ByteArray` | `[B` | `JByteArray<'local>` |
| `list<T>` | `Array<T>` | `[L...;` | `env.new_object_array()` |
| `option<u64>` | `Long?` | `Ljava/lang/Long;` | boxed or `JObject::null()` |
| `option<u32>` | `Int?` | `Ljava/lang/Integer;` | boxed or `JObject::null()` |
| `option<string>` | `String?` | `Ljava/lang/String;` | `.is_null()` check |
| `option<T>` (record) | `T?` | `L...;` | nullable `JObject` |
| `result<T, E>` | return T, throw on E | exception | `env.throw_new()` |
| `tuple<A, B>` | `Pair<A, B>` | `Lkotlin/Pair;` | `env.new_object()` |
| `tuple<A, B, C>` | `Triple<A, B, C>` | `Lkotlin/Triple;` | `env.new_object()` |
| record | `@Keep class` | `L{pkg}/{Name};` | `env.new_object()` |
| variant | `@Keep sealed class` | `L{pkg}/{Name}${Case};` | `env.new_object()` |
| enum | `enum class` | `L{pkg}/{Name};` | `env.call_static_method()` |
| flags | `Long` (raw value) | `J` | `jlong` |
| type alias | `typealias` | follows target | follows target |
| `error-context` | `String` | `Ljava/lang/String;` | `JString` |

## Reference: Zcash Android SDK Patterns

Source: `/Users/schell/code/zcash-android-wallet-sdk/main/backend-lib/`

### Rust Side

- **Entry point:** `lib.rs` (~3733 lines), all functions named
  `Java_cash_z_ecc_android_sdk_internal_jni_RustBackend_<methodName>`
- **Signature:**
  ```rust
  #[unsafe(no_mangle)]
  pub extern "C" fn Java_..._methodName<'local>(
      mut env: JNIEnv<'local>,
      _: JClass<'local>,
      // ...params...
  ) -> jobject {
      let res = catch_unwind(&mut env, |env| {
          // work here
          Ok(result.into_raw())
      });
      unwrap_exc_or(&mut env, res, ptr::null_mut())
  }
  ```
- **Error handling:** Two-layer — `catch_unwind` catches panics,
  `unwrap_exc_or` converts errors to `RuntimeException` via
  `env.throw_new()`.
- **Object construction:** `env.new_object("class/path", "(descriptor)V", &[args])`
- **Sealed class variants:** `env.new_object("class/path$SubclassName", ...)`
- **jni crate version:** 0.21 (default-features = false)

### Kotlin Side

- **Native declarations:** `@JvmStatic private external fun` in companion
  object
- **Model classes:** `@Keep class JniFoo(val field: Type)` — `@Keep` prevents
  ProGuard stripping
- **Library loading:** `System.loadLibrary("zcashwalletsdk")` via double-
  checked locking

### Build System

- Gradle plugin: `org.mozilla.rust-android-gradle.rust-android`
- Cargo crate type: `["staticlib", "cdylib"]` -> produces `.so`
- Targets: arm, arm64, x86, x86_64

## Estimated Scope

| Component | Est. Lines | Effort |
|-----------|-----------|--------|
| `names.rs` additions + tests | ~80 | Small |
| `witffi-rust` refactor: idiomatic types + trait | ~200 | Medium |
| `witffi-rust`: `witffi_register_ffi!` (moved repr(C) + conversion) | ~400 | Medium-High |
| `witffi-rust`: `witffi_register_jni!` (JNI bridge) | ~700 | Medium-High |
| `witffi-kotlin/generate.rs` (Kotlin output only) | ~800 | Medium |
| CLI integration | ~40 | Small |
| Tests (witffi-rust refactor + witffi-kotlin) | ~300 | Medium |
| Example updates | ~100 | Small |
| **Total** | **~2620** | |
