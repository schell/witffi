# Kotlin/Android Bindings Generator — Research & Plan

**Date:** 2026-02-20
**Status:** Blocked — waiting for zcash Android team response on JNI vs JNA

## Open Question

We asked the zcash Android team whether the direct JNI approach in
`zcash-android-wallet-sdk` was a deliberate choice over JNA/JNR, and whether
they'd recommend the same approach if a code generator handled the boilerplate.
Their answer will determine the generator architecture.

### Draft Question Sent to Team

> **Context:** I'm building `witffi`, a code generator that reads WIT
> (WebAssembly Interface Types) files and produces native FFI bindings for
> multiple languages. We already have Rust C-ABI scaffolding, Swift, and are
> now designing the Kotlin/Android generator.
>
> **Question about the JNI approach in `zcash-android-wallet-sdk`:**
>
> The current SDK uses direct JNI — the Rust side uses the `jni` crate to
> construct Kotlin objects via `env.new_object()`, sealed class subclasses via
> `$SubclassName`, and handles errors by throwing `RuntimeException`. There's no
> intermediate C-ABI layer (no `FfiByteBuffer`-style structs, no JNA/JNR).
>
> Was this a deliberate architectural choice to avoid JNA/JNR, or was it more of
> an organic evolution? Specifically:
>
> 1. **Was JNA/JNR ever considered and rejected?** If so, what were the main
>    reasons — performance, dependency size, complexity of type mapping, Android
>    compatibility concerns?
>
> 2. **Are there pain points with the current direct-JNI approach?** For
>    example: the tight coupling between Rust and Kotlin class paths (if you
>    rename a Kotlin class, Rust JNI code breaks), the verbose
>    `env.new_object()` / descriptor-string boilerplate, or the need to keep
>    JNI signatures in sync manually?
>
> 3. **If you were starting fresh with a code generator producing the JNI bridge
>    automatically, would you still prefer direct JNI over JNA/JNR?** The
>    tradeoffs as I see them:
>    - **Direct JNI (current approach):** Zero extra dependencies, constructs
>      rich Kotlin types (sealed classes, nullable fields) directly from Rust,
>      no double-marshaling. But requires generating Rust JNI code that knows
>      JVM class paths.
>    - **JNA/JNR over C-ABI:** Reuses the same C-ABI layer as Swift/Go
>      bindings (simpler generator), but adds a runtime dependency,
>      reflection-based overhead, and needs a Kotlin conversion layer on top of
>      the C structs.
>
> Any opinions or lessons learned would be very helpful for the `witffi` design.

## Architecture Options

### Option A: Direct JNI (two-sided generation)

Generate **both** Kotlin and Rust code:

- **Kotlin side:** `@Keep` model classes (sealed classes for variants, regular
  classes for records), `external fun` declarations in a companion object,
  `System.loadLibrary()` loader.
- **Rust side:** `Java_` JNI functions using the `jni` crate. Each function
  wraps `catch_unwind` + `unwrap_exc_or`, calls the witffi trait method, and
  constructs JVM objects via `env.new_object()`.

**Pros:**
- Zero extra dependencies (JNI is built into Android NDK)
- Constructs rich Kotlin types directly (sealed classes, nullable fields)
- No double-marshaling — Rust -> JVM objects in one step
- Matches the pattern the zcash SDK already uses
- No reflection overhead

**Cons:**
- Generator must produce Rust code that knows JVM class paths (tight coupling)
- More complex generator — two output languages
- The C-ABI scaffolding from witffi-rust is NOT reused; JNI is a separate path
- JNI descriptor strings are error-prone (but auto-generated, so less of an issue)

### Option B: JNA/JNR over C-ABI (Kotlin-side only generation)

Generate **only** Kotlin code that calls the existing C-ABI functions:

- **Kotlin side:** JNA `Library` interface mapping C functions, Kotlin wrapper
  classes that convert C structs to idiomatic Kotlin types.
- **Rust side:** Reuses the existing C-ABI from witffi-rust (no new Rust code).

**Pros:**
- Simpler generator — only produces Kotlin
- Reuses the same C-ABI layer as Swift/Go
- Looser coupling — Kotlin code only depends on C function names, not JVM internals

**Cons:**
- Adds JNA/JNR runtime dependency (~1-2 MB)
- Reflection-based function lookup at runtime
- Double-marshaling: C structs -> Kotlin objects (conversion layer needed)
- Harder to construct rich Kotlin types (sealed classes) from flat C structs
- JNA has had Android compatibility issues historically

## Reference: Zcash Android SDK JNI Patterns

Source: `/Users/schell/code/zcash-android-wallet-sdk/main/backend-lib/`

### Rust Side

- **Entry point:** `lib.rs` (~3733 lines), all functions named
  `Java_cash_z_ecc_android_sdk_internal_jni_RustBackend_<methodName>`
- **Signature:**
  ```rust
  #[unsafe(no_mangle)]
  pub extern "C" fn Java_..._methodName<'local>(
      mut env: JNIEnv<'local>,
      _: JClass<'local>,
      // ...params...
  ) -> jobject {
      let res = catch_unwind(&mut env, |env| {
          // work here, return anyhow::Result<T>
          Ok(result.into_raw())
      });
      unwrap_exc_or(&mut env, res, ptr::null_mut())
  }
  ```
- **Error handling:** Two-layer — `catch_unwind` catches panics,
  `unwrap_exc_or` converts anyhow errors to `RuntimeException` via
  `env.throw_new()`. Sentinels: `-1` (int/long), `JNI_FALSE` (bool),
  `null_mut()` (objects).
- **Object construction:** `env.new_object("class/path", "(descriptor)V", &[args])`
- **Sealed class variants:** `env.new_object("class/path$SubclassName", ...)`
- **jni crate version:** 0.21 (default-features = false)

### Kotlin Side

- **Native declarations:** `@JvmStatic private external fun` in companion object
- **Model classes:** `@Keep class JniFoo(val field: Type)` — `@Keep` prevents
  ProGuard stripping. Sealed classes for variants, `data object` for
  fieldless variants.
- **Library loading:** `System.loadLibrary("zcashwalletsdk")` via
  `NativeLibraryLoader` with double-checked locking
- **Suspend wrappers:** Public API wraps external funs in
  `withContext(Dispatchers.IO)`

### Type Mapping

| WIT Type | Kotlin Type | JNI Type | Rust JNI Type |
|----------|-------------|----------|---------------|
| `string` | `String` | `JString` | `JString<'local>` |
| `string` (return) | `String` | `jstring` | `jstring` |
| `list<u8>` | `ByteArray` | `JByteArray` | `JByteArray<'local>` |
| `u32` | `Long` | `jlong` | `jlong` (cast) |
| `u64` | `Long` | `jlong` | `jlong` (cast) |
| `s32` | `Int` | `jint` | `jint` |
| `s64` | `Long` | `jlong` | `jlong` |
| `bool` | `Boolean` | `jboolean` | `jboolean` |
| `option<u64>` | `Long` (sentinel -1) | `jlong` | `jlong` |
| `option<string>` | `String?` | `JString` | `.is_null()` check |
| `option<T>` (in obj) | `T?` | boxed `java/lang/Long` | `JObject::null()` |
| record | `@Keep class` | `JObject` | `env.new_object()` |
| variant | `@Keep sealed class` | `JObject` | `env.new_object("...$Variant")` |
| `result<T, E>` | return T, throw on E | exception | `env.throw_new()` |
| `list<T>` | `Array<T>` | `JObjectArray` | `rust_vec_to_java()` |

### Build System

- Gradle plugin: `org.mozilla.rust-android-gradle.rust-android`
- Cargo crate type: `["staticlib", "cdylib"]` -> produces `.so`
- Targets: arm, arm64, x86, x86_64

## Architecture-Independent Work (ready to implement)

These items are needed regardless of the JNI vs JNA decision:

1. **Name conversion functions** in `witffi-core/src/names.rs`:
   - `to_kotlin_type(name)` — PascalCase (same as Swift)
   - `to_kotlin_ident(name)` — camelCase (same as Swift)
   - `escape_kotlin_keyword(name)` — backtick escaping for: `when`, `fun`,
     `val`, `var`, `is`, `in`, `object`, `typealias`, `data`, `sealed`,
     `companion`, `by`, `inner`, `out`, `it`, `as`

2. **Package path derivation** — `zcash:eip681` -> `zcash.eip681`, with
   `--kotlin-package` CLI override

3. **Kotlin model class generation** — `@Keep` classes, sealed class
   hierarchies for variants, constructor validation

4. **`external fun` declarations** — `@JvmStatic private external fun` in
   companion object

5. **CLI integration** — `Language::Kotlin` variant, output file(s)

## File Structure (proposed)

```
crates/
  witffi-kotlin/
    Cargo.toml          # deps: witffi-core, wit-parser, anyhow, heck
    src/
      lib.rs            # pub use generate::KotlinGenerator;
      generate.rs       # KotlinGenerator<'a>

examples/
  eip681-kotlin/        # (structure depends on JNI vs JNA decision)
```

## Next Steps

1. Get zcash team response on JNI vs JNA
2. Make architecture decision
3. Implement name conversion functions
4. Implement KotlinGenerator (Kotlin model classes + external funs)
5. Implement bridge layer (Rust JNI or Kotlin JNA, depending on decision)
6. Create eip681-kotlin example
7. Add CLI support for `--lang kotlin`
